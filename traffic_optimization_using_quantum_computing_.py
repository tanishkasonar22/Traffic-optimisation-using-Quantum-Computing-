# -*- coding: utf-8 -*-
"""Traffic_Optimization_using_Quantum_Computing_.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Mwk6-Ejw-8Ac4IFzabOJsMkFjNd1KAFF
"""

import numpy
print(numpy.__version__)

!pip install numpy==1.23.5

!pip install osmnx
!pip install osmnx --upgrade

!apt-get update
!apt-get install -y libspatialindex-dev
!pip install osmnx

from google.colab import drive
drive.mount('/content/drive')
!pip install osmnx -t "/content/drive/My Drive/colab_packages"

import sys
sys.path.append("/content/drive/My Drive/colab_packages")

!pip install osmnx -q
# Or with a mirror
!pip install osmnx -i https://pypi.tuna.tsinghua.edu.cn/simple

!pip install numpy osmnx -q

!pip install osmnx folium cirq networkx numpy scipy IPython matplotlib --quiet



import osmnx as ox
import networkx as nx
from collections import defaultdict
import folium
import cirq
import numpy as np
from scipy.optimize import minimize
import IPython.display
from itertools import combinations
import gc
import matplotlib.colors as mcolors

# Updated legend with traffic signal entry
legend_html = """
<div style="position: fixed; bottom: 50px; right: 50px; width: 180px; height: 260px;
            background-color: white; border:2px solid grey; z-index:9999; font-size:14px;">
 <b>Traffic Map Legend</b> <br>
 <i class="fa fa-exclamation-triangle fa-1x" style="color:red"></i> Traffic Jam <br>
 <span style="color:purple">Unique Colors</span> Car Routes (Before) <br>
 <i class="fa fa-car fa-1x" style="color:blue"></i> Car Start (Before) <br>
 <i class="fa fa-flag-checkered fa-1x" style="color:red"></i> Car End (Before) <br>
 <i class="fa fa-car fa-1x" style="color:green"></i> Car Start (After) <br>
 <i class="fa fa-flag-checkered fa-1x" style="color:darkgreen"></i> Car End (After) <br>
 <span style="color:green">Green Line</span> Smarter Route (After) <br>
 <i class="fa fa-traffic-light fa-1x" style="color:orange"></i> Traffic Signal <br>
</div>
"""

# Load graph for Times Square
def load_map():
    print("Loading map data for Times Square...")
    G = ox.graph_from_point((40.7558, -73.9864), dist=300, network_type='drive', simplify=False)
    ox.distance.add_edge_lengths(G)
    print(f"Graph loaded with {len(G.nodes)} nodes and {len(G.edges)} edges")
    return G

# Generate synthetic routes with forced congestion
def generate_synthetic_routes(G, n_cars=18):
    print(f"Generating {n_cars} synthetic routes...")
    nodes = list(G.nodes)
    if len(nodes) < 5:
        raise ValueError("Graph too small")

    original_routes = {}
    major_nodes = nodes[:min(20, len(nodes))]
    for car_id in range(n_cars):
        start = major_nodes[car_id % len(major_nodes)]
        mid = major_nodes[(car_id + 1) % len(major_nodes)]
        end = major_nodes[(car_id + 2) % len(major_nodes)]
        try:
            path1 = nx.shortest_path(G, start, mid, weight='length')
            path2 = nx.shortest_path(G, mid, end, weight='length')
            route = path1[:-1] + path2
            original_routes[car_id] = [list(zip(route, route[1:]))]
        except nx.NetworkXNoPath:
            edge = [(start, mid)] if G.has_edge(start, mid) else [(nodes[0], nodes[1])]
            original_routes[car_id] = [edge]

    segment_counts = defaultdict(int)
    for paths in original_routes.values():
        for u, v in paths[0]:
            segment_counts[(u, v)] += 1
    congested_segments = {seg: count for seg, count in segment_counts.items() if count >= 4}
    print(f"Congested segments: {len(congested_segments)}")
    return congested_segments, original_routes

def identify_critical_intersections(G, congested_segments, original_routes, min_distance=80):
    """
    Identify critical intersections based on congestion, ensuring signals are not too close and tracking car directions.

    Parameters:
    - G: NetworkX graph
    - congested_segments: Dictionary of congested road segments and their car counts
    - original_routes: Dictionary of car routes before optimization
    - min_distance: Minimum distance (in meters) between traffic signals (default=80)

    Returns:
    - Dictionary of critical intersections with their loads and allowed directions
    """
    print("Identifying critical intersections based on congestion...")
    intersection_load = defaultdict(int)
    critical_intersections = {}
    signal_coords = []  # Store coordinates of placed signals
    signal_directions = {}  # Store allowed directions for each signal

    # Calculate load for each intersection from valid congested segments
    for (u, v), count in congested_segments.items():
        # Check if the edge (u, v) exists in the graph
        if G.has_edge(u, v) or G.has_edge(v, u):  # Handle undirected graph
            if u in G.nodes and v in G.nodes:
                intersection_load[u] += count
                intersection_load[v] += count
        else:
            print(f"Warning: Invalid edge {(u, v)} in congested_segments - skipping")

    # Add load from routes passing through valid intersections
    for paths in original_routes.values():
        for u, v in paths[0]:
            if u in G.nodes and v in G.nodes and G.has_edge(u, v):
                if (u, v) in congested_segments or (v, u) in congested_segments:
                    intersection_load[u] += 1
                    intersection_load[v] += 1

    # Prioritize signals at endpoints of valid congested segments and nearby nodes
    considered_nodes = set()
    for (u, v), _ in congested_segments.items():
        if G.has_edge(u, v) or G.has_edge(v, u):  # Ensure edge exists
            for node in [u, v]:  # Check both endpoints of congested segments
                if node in G.nodes and node not in considered_nodes:
                    considered_nodes.add(node)
                    lat1, lon1 = G.nodes[node]['y'], G.nodes[node]['x']

                    # Check if this signal is too close to existing signals (node distance)
                    too_close_node = any(ox.distance.great_circle(lat1, lon1, existing_lat, existing_lon) < min_distance
                                       for existing_lat, existing_lon in signal_coords)

                    # Check if this signal would be on the same segment without an intersection
                    too_close_segment = False
                    for existing_node, _ in critical_intersections.items():
                        if existing_node in G.nodes:
                            existing_coords = (G.nodes[existing_node]['y'], G.nodes[existing_node]['x'])
                            # Simplified check: ensure no direct edge without an intersection
                            if G.has_edge(node, existing_node):
                                too_close_segment = True
                                break

                    if not (too_close_node or too_close_segment):
                        critical_intersections[node] = intersection_load[node]
                        signal_coords.append((lat1, lon1))
                        # Determine allowed directions at this intersection
                        directions = determine_directions(G, node)
                        signal_directions[node] = directions

    # Add signals for all nearby nodes (within 20 meters) of valid congested segments, regardless of load
    for node in G.nodes:
        if node not in considered_nodes:
            lat1, lon1 = G.nodes[node]['y'], G.nodes[node]['x']
            # Check proximity to valid congested segments (within 20 meters)
            close_to_congestion = False
            for u, v in congested_segments.keys():
                if G.has_edge(u, v) or G.has_edge(v, u):  # Ensure edge exists
                    if u in G.nodes and v in G.nodes:
                        close_to_congestion |= (ox.distance.great_circle(lat1, lon1, G.nodes[u]['y'], G.nodes[u]['x']) < 20
                                             or ox.distance.great_circle(lat1, lon1, G.nodes[v]['y'], G.nodes[v]['x']) < 20)
            if close_to_congestion:
                too_close_node = any(ox.distance.great_circle(lat1, lon1, existing_lat, existing_lon) < min_distance
                                   for existing_lat, existing_lon in signal_coords)
                too_close_segment = False
                for existing_node, _ in critical_intersections.items():
                    if existing_node in G.nodes:
                        existing_coords = (G.nodes[existing_node]['y'], G.nodes[existing_node]['x'])
                        # Simplified check: ensure no direct edge without an intersection
                        if G.has_edge(node, existing_node):
                            too_close_segment = True
                            break

                if not (too_close_node or too_close_segment):
                    critical_intersections[node] = intersection_load.get(node, 0)
                    signal_coords.append((lat1, lon1))
                    directions = determine_directions(G, node)
                    signal_directions[node] = directions

    print(f"Critical intersections (after congestion focus and spacing): {len(critical_intersections)}")
    return critical_intersections, signal_directions

def determine_directions(G, node):
    """
    Determine allowed car movement directions at a given intersection (node).

    Parameters:
    - G: NetworkX graph
    - node: Node ID of the intersection

    Returns:
    - List of strings describing allowed directions (e.g., "Northbound", "Southbound", etc.)
    """
    directions = []
    if node not in G.nodes:
        return directions

    # Get all edges connected to this node
    edges = [(u, v) for u, v in G.edges(node) if u == node or v == node]

    for u, v in edges:
        # Use node coordinates to estimate direction (simplified approximation)
        if u == node:
            lat1, lon1 = G.nodes[u]['y'], G.nodes[u]['x']
            lat2, lon2 = G.nodes[v]['y'], G.nodes[v]['x']
        else:
            lat1, lon1 = G.nodes[v]['y'], G.nodes[v]['x']
            lat2, lon2 = G.nodes[u]['y'], G.nodes[u]['x']

        # Calculate bearing (simplified direction) using longitude/latitude difference
        delta_lon = lon2 - lon1
        delta_lat = lat2 - lat1
        angle = np.degrees(np.arctan2(delta_lon, delta_lat))
        if angle < 0:
            angle += 360

        # Map angle to cardinal directions (simplified)
        if 315 <= angle or angle < 45:
            direction = "Northbound"
        elif 45 <= angle < 135:
            direction = "Eastbound"
        elif 135 <= angle < 225:
            direction = "Southbound"
        else:
            direction = "Westbound"
        directions.append(direction)

    # Remove duplicates and sort for clarity
    directions = sorted(list(set(directions)))
    return directions

# Find alternative routes
def find_alternative_routes(G, routes, congested_segments, max_alts=3):
    print("Finding alternative routes...")
    G_simple = nx.Graph(G) if G.is_multigraph() else G
    car_routes = {}
    for car_id, paths in routes.items():
        if not paths or not paths[0]:
            car_routes[car_id] = [[(list(G.nodes)[0], list(G.nodes)[1])]]
            continue
        source, dest = paths[0][0][0], paths[0][-1][1]
        alts = []
        try:
            for path in nx.shortest_simple_paths(G_simple, source, dest, weight='length'):
                if len(alts) >= max_alts: break
                path_edges = list(zip(path, path[1:]))
                if path_edges not in alts:
                    alts.append(path_edges)
            if not alts: raise nx.NetworkXNoPath
        except nx.NetworkXNoPath:
            alts = [paths[0]]
        car_routes[car_id] = alts[:max_alts]
    return car_routes

# Formulate QUBO for QAOA
def formulate_qubo(routes, congested_segments, penalty=100):
    print("Formulating QUBO...")
    n_cars = len(routes)
    n_alts = 3
    n_vars = n_cars * n_alts
    var_map = {(car_id, alt_id): car_id * n_alts + alt_id for car_id in routes for alt_id in range(n_alts)}
    Q = np.zeros((n_vars, n_vars))

    segment_usage = defaultdict(list)
    for car_id, alts in routes.items():
        for alt_id in range(min(n_alts, len(alts))):
            idx = var_map[(car_id, alt_id)]
            for u, v in alts[alt_id]:
                segment_usage[(u, v)].append(idx)

    for _, indices in segment_usage.items():
        for idx in indices: Q[idx, idx] += 1
        for i, j in combinations(indices, 2):
            Q[i, j] += 2; Q[j, i] += 2

    for car_id in routes:
        indices = [var_map[(car_id, j)] for j in range(min(n_alts, len(routes[car_id])))]
        for idx in indices: Q[idx, idx] -= penalty
        for i, j in combinations(indices, 2):
            Q[i, j] += 2 * penalty; Q[j, i] += 2 * penalty

    return Q, var_map

# Simplified QAOA with Cirq
def solve_qaoa_with_cirq(Q, num_vars, p=1):
    print(f"Solving QAOA with {num_vars} variables, p={p}...")
    qubits = [cirq.LineQubit(i) for i in range(num_vars)]
    simulator = cirq.Simulator()
    best_solution = None
    best_energy = float('inf')

    def evaluate_energy(bitstring):
        return sum(Q[i, j] * bitstring[i] * bitstring[j] for i in range(num_vars) for j in range(num_vars))

    def create_qaoa_circuit(gamma, beta):
        circuit = cirq.Circuit()
        circuit.append(cirq.H.on_each(*qubits))
        for layer in range(p):
            for i in range(num_vars):
                if abs(Q[i, i]) > 1e-6:
                    circuit.append(cirq.rz(2 * gamma[layer] * Q[i, i]).on(qubits[i]))
                for j in range(i + 1, num_vars):
                    if abs(Q[i, j]) > 1e-6:
                        circuit.append(cirq.CNOT(qubits[i], qubits[j]))
                        circuit.append(cirq.rz(2 * gamma[layer] * Q[i, j]).on(qubits[j]))
                        circuit.append(cirq.CNOT(qubits[i], qubits[j]))
            circuit.append(cirq.rx(2 * beta[layer]).on_each(*qubits))
        circuit.append(cirq.measure(*qubits, key='result'))
        return circuit

    def objective(params):
        nonlocal best_solution, best_energy
        gamma = params[:p]
        beta = params[p:]
        circuit = create_qaoa_circuit(gamma, beta)
        result = simulator.run(circuit, repetitions=500)
        measurements = result.measurements['result']
        energy = min(evaluate_energy(bitstring) for bitstring in measurements)
        if energy < best_energy:
            best_energy = energy
            best_solution = tuple(measurements[np.argmin([evaluate_energy(b) for b in measurements])])
        return energy

    initial_params = np.random.uniform(0, np.pi, 2 * p)
    result = minimize(objective, initial_params, method='COBYLA', options={'maxiter': 20})
    return {i: int(bit) for i, bit in enumerate(best_solution)} if best_solution else {i: 0 for i in range(num_vars)}

# Redistribute cars with QAOA
def redistribute_cars_with_qaoa(routes, congested_segments, p=1):
    print("Redistributing cars with QAOA...")
    n_alts = 3
    var_map = {(car_id, alt_id): car_id * n_alts + alt_id for car_id in routes for alt_id in range(n_alts)}
    Q, _ = formulate_qubo(routes, congested_segments)

    final_routes = {}
    for group in [range(0, 6), range(6, 12), range(12, 18)]:
        subset_routes = {car_id: routes[car_id] for car_id in group}
        subset_var_map = {(car_id, alt_id): var_map[(car_id, alt_id)] for car_id in group for alt_id in range(n_alts)}
        subset_vars = list(subset_var_map.values())
        Q_subset = Q[np.ix_(subset_vars, subset_vars)]
        solution = solve_qaoa_with_cirq(Q_subset, len(subset_var_map), p)
        for car_id in group:
            for alt_id in range(min(n_alts, len(routes[car_id]))):
                if solution.get(subset_var_map[(car_id, alt_id)], 0) == 1:
                    final_routes[car_id] = [routes[car_id][alt_id]]
                    break
            if car_id not in final_routes and routes[car_id]:
                final_routes[car_id] = [routes[car_id][0]]
    return final_routes

# Compute signal timings with printed output
def compute_signal_timings(G, critical_data, routes_before, routes_after=None):
    """
    Compute signal timings for critical intersections, including allowed directions.

    Parameters:
    - G: NetworkX graph
    - critical_data: Tuple of (critical_intersections, signal_directions) from identify_critical_intersections
    - routes_before: Dictionary of car routes before optimization
    - routes_after: Dictionary of car routes after optimization (optional, for 'after' state)

    Returns:
    - Dictionary of signal timings with coordinates and directions
    """
    print("Computing signal timings with directions...")
    signal_timings = {}
    max_cycle = 120  # 2-minute cycle
    critical_intersections, signal_directions = critical_data

    for node in critical_intersections:
        # Use routes_before if routes_after is not provided (for 'before' state)
        routes_to_use = routes_after if routes_after else routes_before
        before_count = sum(1 for paths in routes_before.values() for u, v in paths[0] if u == node or v == node)
        after_count = sum(1 for paths in routes_to_use.values() for u, v in paths[0] if u == node or v == node)
        green = min(60, max(20, after_count * 2)) if after_count > 0 else max(20, before_count * 1.5)
        red = max_cycle - green - 5  # 5s yellow
        signal_timings[node] = {
            'green': green,
            'yellow': 5,
            'red': red,
            'coords': (G.nodes[node]['y'], G.nodes[node]['x']),
            'directions': signal_directions.get(node, [])  # Include allowed directions
        }
        print(f"Traffic Signal @ Node {node}: Green={green}s, Red={red}s, Directions={', '.join(signal_directions.get(node, []))} "
              f"(Before: {before_count} cars, After: {after_count} cars)")
    return signal_timings

# Visualize before optimization with unique colors
def visualize_before(G, original_routes, congested_segments, critical_intersections, signal_directions):
    print("Visualizing before optimization...")
    m = folium.Map(location=(40.7558, -73.9864), zoom_start=15)
    color_list = list(mcolors.TABLEAU_COLORS.values()) + list(mcolors.CSS4_COLORS.values())[:18]
    unique_colors = color_list[:len(original_routes)]

    for (u, v), count in congested_segments.items():
        if u in G.nodes and v in G.nodes and G.has_edge(u, v):
            coords = [(G.nodes[u]['y'], G.nodes[u]['x']), (G.nodes[v]['y'], G.nodes[v]['x'])]
            folium.PolyLine(coords, color='red', weight=8, opacity=0.8, tooltip=f'Jam: {count} cars').add_to(m)
            folium.Marker(coords[0], icon=folium.Icon(color='red', icon='exclamation-triangle', prefix='fa')).add_to(m)

    for car_id, path in original_routes.items():
        if path and path[0]:
            points = [(G.nodes[u]['y'], G.nodes[u]['x']) for u, v in path[0] if u in G.nodes and v in G.nodes and G.has_edge(u, v)]
            if len(points) >= 2:
                unique_points = list(dict.fromkeys(points))
                car_color = unique_colors[car_id % len(unique_colors)]
                folium.PolyLine(unique_points, color=car_color, weight=4, tooltip=f'Car {car_id}').add_to(m)
                folium.Marker(unique_points[0], icon=folium.Icon(color='blue', icon='car', prefix='fa')).add_to(m)
                folium.Marker(unique_points[-1], icon=folium.Icon(color='red', icon='flag-checkered', prefix='fa')).add_to(m)

    # Add traffic signals (critical intersections) to the before map
    signal_timings = compute_signal_timings(G, (critical_intersections, signal_directions), original_routes)
    for node, timings in signal_timings.items():
        directions_str = ", ".join(timings['directions']) if timings['directions'] else "All directions"
        folium.Marker(
            timings['coords'],
            icon=folium.Icon(color='orange', icon='traffic-light', prefix='fa', icon_size=(30, 30)),
            tooltip=f"Traffic Signal @ Node {node}: Green={timings['green']}s, Red={timings['red']}s, Directions={directions_str}"
        ).add_to(m)
        folium.Circle(
            timings['coords'],
            radius=20,
            color='orange',
            fill=True,
            fill_opacity=0.4,
            tooltip=f"Busy Intersection: Node {node}, Directions={directions_str}"
        ).add_to(m)

    m.get_root().html.add_child(folium.Element(legend_html))
    return m

# Visualize after optimization with enhanced traffic signals
def visualize_after_with_signals(G, optimized_routes, congested_segments, signal_timings):
    print("Visualizing after optimization with enhanced traffic signals and directions...")
    m = folium.Map(location=(40.7558, -73.9864), zoom_start=15)

    for (u, v), count in congested_segments.items():
        if u in G.nodes and v in G.nodes:
            coords = [(G.nodes[u]['y'], G.nodes[u]['x']), (G.nodes[v]['y'], G.nodes[v]['x'])]
            folium.PolyLine(coords, color='red', weight=8, opacity=0.5, tooltip=f'Jam: {count} cars').add_to(m)
            folium.Marker(coords[0], icon=folium.Icon(color='red', icon='exclamation-triangle', prefix='fa')).add_to(m)

    for car_id, paths in optimized_routes.items():
        if paths and paths[0]:
            points = [(G.nodes[u]['y'], G.nodes[u]['x']) for u, v in paths[0] if u in G.nodes and v in G.nodes]
            if len(points) >= 2:
                unique_points = list(dict.fromkeys(points))
                folium.PolyLine(unique_points, color='green', weight=4, dash_array='5', tooltip=f'Car {car_id}').add_to(m)
                folium.Marker(unique_points[0], icon=folium.Icon(color='green', icon='car', prefix='fa')).add_to(m)
                folium.Marker(unique_points[-1], icon=folium.Icon(color='darkgreen', icon='flag-checkered', prefix='fa')).add_to(m)

    # Enhanced traffic signal visualization with directions
    for node, timings in signal_timings.items():
        directions_str = ", ".join(timings['directions']) if timings['directions'] else "All directions"
        folium.Marker(
            timings['coords'],
            icon=folium.Icon(color='orange', icon='traffic-light', prefix='fa', icon_size=(30, 30)),
            tooltip=f"Traffic Signal @ Node {node}: Green={timings['green']}s, Red={timings['red']}s, Directions={directions_str}"
        ).add_to(m)
        folium.Circle(
            timings['coords'],
            radius=20,
            color='orange',
            fill=True,
            fill_opacity=0.4,
            tooltip=f"Busy Intersection: Node {node}, Directions={directions_str}"
        ).add_to(m)

    m.get_root().html.add_child(folium.Element(legend_html))
    return m

# Main execution
if __name__ == "__main__":
    try:
        import cirq
    except ImportError:
        print("Installing Cirq...")
        !pip install cirq --quiet
        import cirq

    print(f"Using osmnx version: {ox.__version__}")
    G = load_map()
    congested_segments, original_routes = generate_synthetic_routes(G)
    critical_intersections, signal_directions = identify_critical_intersections(G, congested_segments, original_routes)

    map_before = visualize_before(G, original_routes, congested_segments, critical_intersections, signal_directions)
    map_before.save("map_before.html")
    print("Before map saved as 'map_before.html'")
    IPython.display.display(map_before)
    gc.collect()

    optimized_routes = find_alternative_routes(G, original_routes, congested_segments)
    final_routes = redistribute_cars_with_qaoa(optimized_routes, congested_segments, p=1)
    signal_timings = compute_signal_timings(G, (critical_intersections, signal_directions), original_routes, final_routes)

    map_after = visualize_after_with_signals(G, final_routes, congested_segments, signal_timings)
    map_after.save("map_after_with_signals.html")
    print("After map with enhanced signals saved as 'map_after_with_signals.html'")
    IPython.display.display(map_after)

    gc.collect()
    print("Execution completed.")

import osmnx as ox
import networkx as nx
from collections import defaultdict
import folium
import cirq
import numpy as np
from scipy.optimize import minimize
import IPython.display
from itertools import combinations
import gc
import matplotlib.colors as mcolors

# Define legend globally (updated to note unique colors for "before")
legend_html = """
<div style="position: fixed; bottom: 50px; right: 50px; width: 180px; height: 220px;
            background-color: white; border:2px solid grey; z-index:9999; font-size:14px;">
 <b>Traffic Map Legend</b> <br>
 <i class="fa fa-exclamation-triangle fa-1x" style="color:red"></i> Traffic Jam <br>
 <span style="color:purple">Unique Colors</span> Car Routes (Before) <br>
 <i class="fa fa-car fa-1x" style="color:blue"></i> Car Start (Before, Example) <br>
 <i class="fa fa-flag-checkered fa-1x" style="color:red"></i> Car End (Before, Example) <br>
 <i class="fa fa-car fa-1x" style="color:green"></i> Car Start (After) <br>
 <i class="fa fa-flag-checkered fa-1x" style="color:darkgreen"></i> Car End (After) <br>
 <span style="color:green">Green Line</span> Smarter Route (After) <br>
</div>
"""

# Load graph for Times Square
def load_map():
    print("Loading map data for Times Square...")
    G = ox.graph_from_point((40.7558, -73.9864), dist=300, network_type='drive', simplify=False)
    ox.distance.add_edge_lengths(G)
    print(f"Graph loaded with {len(G.nodes)} nodes and {len(G.edges)} edges")
    return G

# Generate routes with forced congestion for 18 cars
def generate_synthetic_routes(G, n_cars=18):
    print(f"Generating synthetic routes with congestion for {n_cars} cars...")
    nodes = list(G.nodes)
    if len(nodes) < 5:
        raise ValueError("Graph too small for meaningful routes")

    original_routes = {}
    major_nodes = nodes[:min(20, len(nodes))]
    print(f"Selected major nodes for congestion: {major_nodes[:3]}...")

    for car_id in range(n_cars):
        start = major_nodes[car_id % len(major_nodes)]
        mid = major_nodes[(car_id + 1) % len(major_nodes)]
        end = major_nodes[(car_id + 2) % len(major_nodes)]
        try:
            path1 = nx.shortest_path(G, start, mid, weight='length')
            path2 = nx.shortest_path(G, mid, end, weight='length')
            route = path1[:-1] + path2
            edge_list = list(zip(route, route[1:]))
            original_routes[car_id] = [edge_list]
            print(f"Car {car_id} original route: {edge_list[:3]}... ({len(edge_list)} edges)")
        except nx.NetworkXNoPath:
            edge_list = [(start, mid)] if G.has_edge(start, mid) else [(nodes[0], nodes[1])] if G.has_edge(nodes[0], nodes[1]) else [(nodes[0], nodes[0])]
            original_routes[car_id] = [edge_list]
            print(f"Car {car_id} fallback route due to no path: {edge_list}")

    segment_counts = defaultdict(int)
    for car_id, paths in original_routes.items():
        for u, v in paths[0]:
            segment_counts[(u, v)] += 1
    congested_segments = {seg: count for seg, count in segment_counts.items() if count >= 4}
    print(f"Found {len(congested_segments)} congested segments: {list(congested_segments.keys())[:3]}...")
    return congested_segments, original_routes

# Find alternative routes
def find_alternative_routes(G, routes, congested_segments, max_alternatives=3):
    print("Finding alternative routes...")
    G_simple = nx.Graph(G) if G.is_multigraph() else G
    car_routes = {}
    for car_id, paths in routes.items():
        if not paths or not paths[0]:
            car_routes[car_id] = [[(list(G.nodes)[0], list(G.nodes)[1])]]
            print(f"Car {car_id} alternatives: [1] (fallback)")
            continue
        source, destination = paths[0][0][0], paths[0][-1][1]
        alternatives = []
        try:
            for path in nx.shortest_simple_paths(G_simple, source, destination, weight='length'):
                if len(alternatives) >= max_alternatives: break
                path_edges = list(zip(path, path[1:]))
                if path_edges not in alternatives:
                    alternatives.append(path_edges)
            if not alternatives:
                raise nx.NetworkXNoPath
        except nx.NetworkXNoPath:
            alternatives = [paths[0]]
        car_routes[car_id] = alternatives[:max_alternatives]
        print(f"Car {car_id} alternatives: {[len(alt) for alt in alternatives]} edges")
    return car_routes

# Formulate QUBO for QAOA
def formulate_qubo(G, routes, congested_segments, penalty_weight=100):
    print("Formulating QUBO for QAOA with Cirq...")
    n_cars = len(routes)
    n_alts = 3
    n_vars = n_cars * n_alts
    var_map = {(car_id, alt_id): car_id * n_alts + alt_id for car_id in routes for alt_id in range(n_alts)}

    Q = np.zeros((n_vars, n_vars))
    segment_usage = defaultdict(list)
    for car_id, alts in routes.items():
        for alt_id in range(min(n_alts, len(alts))):
            idx = var_map[(car_id, alt_id)]
            for u, v in alts[alt_id]:
                segment_usage[(u, v)].append(idx)
    for s, indices in segment_usage.items():
        for idx in indices: Q[idx, idx] += 1
        for idx1, idx2 in combinations(indices, 2):
            Q[idx1, idx2] += 2; Q[idx2, idx1] += 2

    for car_id in routes:
        indices = [var_map[(car_id, j)] for j in range(min(n_alts, len(routes[car_id])))]
        for idx in indices: Q[idx, idx] -= penalty_weight
        for idx1, idx2 in combinations(indices, 2):
            Q[idx1, idx2] += 2 * penalty_weight; Q[idx2, idx1] += 2 * penalty_weight

    print(f"QUBO formulated with {n_vars} variables")
    return Q, var_map

# Solve QAOA with Cirq
def solve_qaoa_with_cirq(Q, num_vars, p=2):
    print(f"Solving QAOA with Cirq, {num_vars} variables, p={p}...")
    qubits = [cirq.LineQubit(i) for i in range(num_vars)]
    simulator = cirq.Simulator()
    best_solution = None
    best_energy = float('inf')

    def evaluate_bitstring(bitstring):
        energy = 0
        for i in range(num_vars):
            for j in range(num_vars):
                energy += Q[i, j] * bitstring[i] * bitstring[j]
        return energy

    def create_qaoa_circuit(gamma, beta):
        circuit = cirq.Circuit()
        circuit.append(cirq.H.on_each(*qubits))
        for layer in range(p):
            for i in range(num_vars):
                if abs(Q[i, i]) > 1e-6:
                    circuit.append(cirq.rz(2 * gamma[layer] * Q[i, i]).on(qubits[i]))
                for j in range(i + 1, num_vars):
                    if abs(Q[i, j]) > 1e-6:
                        circuit.append(cirq.CNOT(qubits[i], qubits[j]))
                        circuit.append(cirq.rz(2 * gamma[layer] * Q[i, j]).on(qubits[j]))
                        circuit.append(cirq.CNOT(qubits[i], qubits[j]))
            circuit.append(cirq.rx(2 * beta[layer]).on_each(*qubits))
        circuit.append(cirq.measure(*qubits, key='result'))
        return circuit

    def objective_function(params):
        nonlocal best_solution, best_energy
        gamma = params[:p]
        beta = params[p:]
        circuit = create_qaoa_circuit(gamma, beta)
        result = simulator.run(circuit, repetitions=1000)
        measurements = result.measurements['result']
        energies = [evaluate_bitstring(bitstring) for bitstring in measurements]
        avg_energy = sum(energies) / len(energies)
        min_energy = min(energies)
        if min_energy < best_energy:
            best_energy = min_energy
            best_solution = tuple(measurements[energies.index(min_energy)])
        print(f"QAOA energy: avg={avg_energy:.2f}, min={min_energy:.2f}")
        return avg_energy

    initial_params = np.random.uniform(0, np.pi, 2 * p)
    result = minimize(objective_function, initial_params, method='COBYLA', options={'maxiter': 50})
    print(f"Optimization result: {result.message}")
    return {i: int(bit) for i, bit in enumerate(best_solution)} if best_solution else {i: 0 for i in range(num_vars)}

# Redistribute cars with QAOA
def redistribute_cars_with_qaoa(routes, congested_segments, p=2):
    print("Redistributing cars with QAOA...")
    n_cars = len(routes)
    n_alts = 3
    var_map = {(car_id, alt_id): car_id * n_alts + alt_id for car_id in routes for alt_id in range(n_alts)}
    Q, _ = formulate_qubo(None, routes, congested_segments)

    final_routes = {}
    for group in [range(0, 6), range(6, 12), range(12, 18)]:
        subset_routes = {car_id: routes[car_id] for car_id in group}
        subset_var_map = {(car_id, alt_id): var_map[(car_id, alt_id)] for car_id in group for alt_id in range(n_alts)}
        subset_vars = list(subset_var_map.values())
        Q_subset = Q[np.ix_(subset_vars, subset_vars)]
        solution = solve_qaoa_with_cirq(Q_subset, len(subset_var_map), p)
        for car_id in group:
            for alt_id in range(min(n_alts, len(routes[car_id]))):
                if solution.get(subset_var_map[(car_id, alt_id)], 0) == 1:
                    final_routes[car_id] = [routes[car_id][alt_id]]
                    break
            if car_id not in final_routes and routes[car_id]:
                final_routes[car_id] = [routes[car_id][0]]
            print(f"Car {car_id} final route: {final_routes[car_id][0][:3]}... ({len(final_routes[car_id][0])} edges)")
    return final_routes

# Visualize before optimization with unique colors
def visualize_before(G, original_routes, _, congested_segments):
    print("Visualizing before optimization (Traffic Jams)...")
    m = folium.Map(location=(40.7558, -73.9864), zoom_start=15)

    # Define a list of unique colors (18 distinct colors for 18 cars)
    color_list = list(mcolors.TABLEAU_COLORS.values()) + list(mcolors.CSS4_COLORS.values())[:18]
    unique_colors = color_list[:len(original_routes)]  # Ensure enough colors

    # Plot congested segments
    for (u, v), count in congested_segments.items():
        if u in G.nodes and v in G.nodes:
            coords = [(G.nodes[u]['y'], G.nodes[u]['x']), (G.nodes[v]['y'], G.nodes[v]['x'])]
            print(f"Plotting congested segment ({u}, {v}): {coords}")
            folium.PolyLine(coords, color='red', weight=8, opacity=0.8,
                            tooltip=f'Traffic Jam: {count} cars').add_to(m)
            folium.Marker(coords[0], icon=folium.Icon(color='red', icon='exclamation-triangle', prefix='fa'),
                          tooltip=f'Jam: {count} cars').add_to(m)

    # Plot each car's route with a unique color
    for car_id, path in original_routes.items():
        if path and path[0]:
            points = [(G.nodes[u]['y'], G.nodes[u]['x']) for u, v in path[0] if u in G.nodes and v in G.nodes]
            if len(points) >= 2:
                unique_points = list(dict.fromkeys(points))
                car_color = unique_colors[car_id % len(unique_colors)]  # Assign unique color
                print(f"Car {car_id} before (color: {car_color}): {unique_points[:3]}... ({len(unique_points)} points)")
                folium.PolyLine(unique_points, color=car_color, weight=4, tooltip=f'Car {car_id} Route').add_to(m)
                folium.Marker(unique_points[0], icon=folium.Icon(color='blue', icon='car', prefix='fa'),
                              tooltip=f'Car {car_id} Start').add_to(m)
                folium.Marker(unique_points[-1], icon=folium.Icon(color='red', icon='flag-checkered', prefix='fa'),
                              tooltip=f'Car {car_id} End').add_to(m)
            else:
                print(f"Car {car_id} before: Insufficient points ({len(points)})")
    m.get_root().html.add_child(folium.Element(legend_html))
    return m

# Visualize after optimization (unchanged)
def visualize_after(G, _, optimized_routes, congested_segments):
    print("Visualizing after optimization (Smarter Routes)...")
    m = folium.Map(location=(40.7558, -73.9864), zoom_start=15)
    for (u, v), count in congested_segments.items():
        if u in G.nodes and v in G.nodes:
            coords = [(G.nodes[u]['y'], G.nodes[u]['x']), (G.nodes[v]['y'], G.nodes[v]['x'])]
            print(f"Plotting congested segment ({u}, {v}): {coords}")
            folium.PolyLine(coords, color='red', weight=8, opacity=0.5,
                            tooltip=f'Traffic Jam: {count} cars').add_to(m)
            folium.Marker(coords[0], icon=folium.Icon(color='red', icon='exclamation-triangle', prefix='fa'),
                          tooltip=f'Jam: {count} cars').add_to(m)

    for car_id, paths in optimized_routes.items():
        if paths and paths[0]:
            points = [(G.nodes[u]['y'], G.nodes[u]['x']) for u, v in paths[0] if u in G.nodes and v in G.nodes]
            if len(points) >= 2:
                unique_points = list(dict.fromkeys(points))
                print(f"Car {car_id} after: {unique_points[:3]}... ({len(unique_points)} points)")
                folium.PolyLine(unique_points, color='green', weight=4, dash_array='5', tooltip=f'Car {car_id} Route').add_to(m)
                folium.Marker(unique_points[0], icon=folium.Icon(color='green', icon='car', prefix='fa'),
                              tooltip=f'Car {car_id} Start').add_to(m)
                folium.Marker(unique_points[-1], icon=folium.Icon(color='darkgreen', icon='flag-checkered', prefix='fa'),
                              tooltip=f'Car {car_id} End').add_to(m)
            else:
                print(f"Car {car_id} after: Insufficient points ({len(points)})")
    m.get_root().html.add_child(folium.Element(legend_html))
    return m

# Main execution
if __name__ == "__main__":
    try:
        import cirq
    except ImportError:
        print("Installing Cirq...")
        !pip install cirq
        import cirq

    print(f"Using osmnx version: {ox.__version__}")
    print("Loading map, generating synthetic routes, and optimizing...")
    G = load_map()
    congested_segments, original_routes = generate_synthetic_routes(G)
    print("Original routes sample:", {k: len(v[0]) for k, v in list(original_routes.items())[:3]})

    map_before = visualize_before(G, original_routes, None, congested_segments)
    map_before.save("map_before.html")
    print("Before map saved as 'map_before.html'")

    optimized_routes = find_alternative_routes(G, original_routes, congested_segments)
    print("Optimized routes sample:", {k: [len(alt) for alt in v] for k, v in list(optimized_routes.items())[:3]})

    final_routes = redistribute_cars_with_qaoa(optimized_routes, congested_segments, p=2)
    print("Final routes sample:", {k: len(v[0]) for k, v in list(final_routes.items())[:3]})

    map_after = visualize_after(G, None, final_routes, congested_segments)
    map_after.save("map_after.html")
    print("After map saved as 'map_after.html'")

    print("Showing Heavy Traffic Jams Before Optimization...")
    IPython.display.display(map_before)
    print("Showing Smarter, Less Congested Routes After Optimization...")
    IPython.display.display(map_after)
    gc.collect()

# Install required packages if not already installed
!pip install osmnx folium cirq ipywidgets numpy matplotlib IPython -q

import osmnx as ox
import networkx as nx
from collections import defaultdict
import folium
import cirq
import numpy as np
from scipy.optimize import minimize
import IPython.display as display
from itertools import combinations
import gc
import matplotlib.colors as mcolors
import ipywidgets as widgets
from ipywidgets import Output, VBox, Tab

# Updated legend with traffic signal entry
legend_html = """
<div style="position: fixed; bottom: 50px; right: 50px; width: 180px; height: 260px;
            background-color: white; border:2px solid grey; z-index:9999; font-size:14px;">
 <b>Traffic Map Legend</b> <br>
 <i class="fa fa-exclamation-triangle fa-1x" style="color:red"></i> Traffic Jam <br>
 <span style="color:purple">Unique Colors</span> Car Routes (Before) <br>
 <i class="fa fa-car fa-1x" style="color:blue"></i> Car Start (Before) <br>
 <i class="fa fa-flag-checkered fa-1x" style="color:red"></i> Car End (Before) <br>
 <i class="fa fa-car fa-1x" style="color:green"></i> Car Start (After) <br>
 <i class="fa fa-flag-checkered fa-1x" style="color:darkgreen"></i> Car End (After) <br>
 <span style="color:green">Green Line</span> Smarter Route (After) <br>
 <i class="fa fa-traffic-light fa-1x" style="color:orange"></i> Traffic Signal <br>
</div>
"""

# Load graph for Times Square
def load_map():
    print("Loading map data for Times Square...")
    G = ox.graph_from_point((40.7558, -73.9864), dist=300, network_type='drive', simplify=False)
    ox.distance.add_edge_lengths(G)
    print(f"Graph loaded with {len(G.nodes)} nodes and {len(G.edges)} edges")
    return G

# Generate synthetic routes with forced congestion
def generate_synthetic_routes(G, n_cars=18):
    print(f"Generating {n_cars} synthetic routes...")
    nodes = list(G.nodes)
    if len(nodes) < 5:
        raise ValueError("Graph too small")
    original_routes = {}
    major_nodes = nodes[:min(20, len(nodes))]
    for car_id in range(n_cars):
        start = major_nodes[car_id % len(major_nodes)]
        mid = major_nodes[(car_id + 1) % len(major_nodes)]
        end = major_nodes[(car_id + 2) % len(major_nodes)]
        try:
            path1 = nx.shortest_path(G, start, mid, weight='length')
            path2 = nx.shortest_path(G, mid, end, weight='length')
            route = path1[:-1] + path2
            original_routes[car_id] = [list(zip(route, route[1:]))]
        except nx.NetworkXNoPath:
            edge = [(start, mid)] if G.has_edge(start, mid) else [(nodes[0], nodes[1])]
            original_routes[car_id] = [edge]
    segment_counts = defaultdict(int)
    for paths in original_routes.values():
        for u, v in paths[0]:
            segment_counts[(u, v)] += 1
    congested_segments = {seg: count for seg, count in segment_counts.items() if count >= 4}
    print(f"Congested segments: {len(congested_segments)}")
    return congested_segments, original_routes

# Identify critical intersections
def identify_critical_intersections(G, congested_segments, original_routes, min_distance=80):
    print("Identifying critical intersections based on congestion...")
    intersection_load = defaultdict(int)
    critical_intersections = {}
    signal_coords = []
    signal_directions = {}
    for (u, v), count in congested_segments.items():
        if G.has_edge(u, v) or G.has_edge(v, u):
            if u in G.nodes and v in G.nodes:
                intersection_load[u] += count
                intersection_load[v] += count
    for paths in original_routes.values():
        for u, v in paths[0]:
            if u in G.nodes and v in G.nodes and G.has_edge(u, v):
                if (u, v) in congested_segments or (v, u) in congested_segments:
                    intersection_load[u] += 1
                    intersection_load[v] += 1
    considered_nodes = set()
    for (u, v), _ in congested_segments.items():
        if G.has_edge(u, v) or G.has_edge(v, u):
            for node in [u, v]:
                if node in G.nodes and node not in considered_nodes:
                    considered_nodes.add(node)
                    lat1, lon1 = G.nodes[node]['y'], G.nodes[node]['x']
                    too_close_node = any(ox.distance.great_circle(lat1, lon1, lat, lon) < min_distance
                                       for lat, lon in signal_coords)
                    too_close_segment = any(G.has_edge(node, existing_node)
                                          for existing_node in critical_intersections)
                    if not (too_close_node or too_close_segment):
                        critical_intersections[node] = intersection_load[node]
                        signal_coords.append((lat1, lon1))
                        signal_directions[node] = determine_directions(G, node)
    for node in G.nodes:
        if node not in considered_nodes:
            lat1, lon1 = G.nodes[node]['y'], G.nodes[node]['x']
            close_to_congestion = any(ox.distance.great_circle(lat1, lon1, G.nodes[u]['y'], G.nodes[u]['x']) < 20
                                    or ox.distance.great_circle(lat1, lon1, G.nodes[v]['y'], G.nodes[v]['x']) < 20
                                    for u, v in congested_segments.keys() if G.has_edge(u, v) or G.has_edge(v, u))
            if close_to_congestion:
                too_close_node = any(ox.distance.great_circle(lat1, lon1, lat, lon) < min_distance
                                   for lat, lon in signal_coords)
                too_close_segment = any(G.has_edge(node, existing_node)
                                      for existing_node in critical_intersections)
                if not (too_close_node or too_close_segment):
                    critical_intersections[node] = intersection_load.get(node, 0)
                    signal_coords.append((lat1, lon1))
                    signal_directions[node] = determine_directions(G, node)
    print(f"Critical intersections: {len(critical_intersections)}")
    return critical_intersections, signal_directions

def determine_directions(G, node):
    directions = []
    if node not in G.nodes:
        return directions
    edges = [(u, v) for u, v in G.edges(node) if u == node or v == node]
    for u, v in edges:
        if u == node:
            lat1, lon1 = G.nodes[u]['y'], G.nodes[u]['x']
            lat2, lon2 = G.nodes[v]['y'], G.nodes[v]['x']
        else:
            lat1, lon1 = G.nodes[v]['y'], G.nodes[v]['x']
            lat2, lon2 = G.nodes[u]['y'], G.nodes[u]['x']
        delta_lon = lon2 - lon1
        delta_lat = lat2 - lat1
        angle = np.degrees(np.arctan2(delta_lon, delta_lat))
        if angle < 0:
            angle += 360
        if 315 <= angle or angle < 45:
            direction = "Northbound"
        elif 45 <= angle < 135:
            direction = "Eastbound"
        elif 135 <= angle < 225:
            direction = "Southbound"
        else:
            direction = "Westbound"
        directions.append(direction)
    return sorted(list(set(directions)))

# Find alternative routes
def find_alternative_routes(G, routes, congested_segments, max_alts=3):
    print("Finding alternative routes...")
    G_simple = nx.Graph(G) if G.is_multigraph() else G
    car_routes = {}
    for car_id, paths in routes.items():
        if not paths or not paths[0]:
            car_routes[car_id] = [[(list(G.nodes)[0], list(G.nodes)[1])]]
            continue
        source, dest = paths[0][0][0], paths[0][-1][1]
        alts = []
        try:
            for path in nx.shortest_simple_paths(G_simple, source, dest, weight='length'):
                if len(alts) >= max_alts: break
                path_edges = list(zip(path, path[1:]))
                if path_edges not in alts:
                    alts.append(path_edges)
            if not alts: raise nx.NetworkXNoPath
        except nx.NetworkXNoPath:
            alts = [paths[0]]
        car_routes[car_id] = alts[:max_alts]
    return car_routes

# Formulate QUBO
def formulate_qubo(routes, congested_segments, penalty=100):
    print("Formulating QUBO...")
    n_cars = len(routes)
    n_alts = 3
    n_vars = n_cars * n_alts
    var_map = {(car_id, alt_id): car_id * n_alts + alt_id for car_id in routes for alt_id in range(n_alts)}
    Q = np.zeros((n_vars, n_vars))
    segment_usage = defaultdict(list)
    for car_id, alts in routes.items():
        for alt_id in range(min(n_alts, len(alts))):
            idx = var_map[(car_id, alt_id)]
            for u, v in alts[alt_id]:
                segment_usage[(u, v)].append(idx)
    for _, indices in segment_usage.items():
        for idx in indices: Q[idx, idx] += 1
        for i, j in combinations(indices, 2):
            Q[i, j] += 2; Q[j, i] += 2
    for car_id in routes:
        indices = [var_map[(car_id, j)] for j in range(min(n_alts, len(routes[car_id])))]
        for idx in indices: Q[idx, idx] -= penalty
        for i, j in combinations(indices, 2):
            Q[i, j] += 2 * penalty; Q[j, i] += 2 * penalty
    return Q, var_map

# Solve QAOA with Cirq
def solve_qaoa_with_cirq(Q, num_vars, p=1):
    print(f"Solving QAOA with {num_vars} variables, p={p}...")
    if num_vars == 0:
        print("No variables to optimize; skipping QAOA.")
        return {}
    qubits = [cirq.LineQubit(i) for i in range(num_vars)]
    simulator = cirq.Simulator()
    best_solution = None
    best_energy = float('inf')
    def evaluate_energy(bitstring):
        return sum(Q[i, j] * bitstring[i] * bitstring[j] for i in range(num_vars) for j in range(num_vars))
    def create_qaoa_circuit(gamma, beta):
        circuit = cirq.Circuit()
        circuit.append(cirq.H.on_each(*qubits))
        for layer in range(p):
            for i in range(num_vars):
                if abs(Q[i, i]) > 1e-6:
                    circuit.append(cirq.rz(2 * gamma[layer] * Q[i, i]).on(qubits[i]))
                for j in range(i + 1, num_vars):
                    if abs(Q[i, j]) > 1e-6:
                        circuit.append(cirq.CNOT(qubits[i], qubits[j]))
                        circuit.append(cirq.rz(2 * gamma[layer] * Q[i, j]).on(qubits[j]))
                        circuit.append(cirq.CNOT(qubits[i], qubits[j]))
            circuit.append(cirq.rx(2 * beta[layer]).on_each(*qubits))
        circuit.append(cirq.measure(*qubits, key='result'))
        return circuit
    def objective(params):
        nonlocal best_solution, best_energy
        gamma = params[:p]
        beta = params[p:]
        circuit = create_qaoa_circuit(gamma, beta)
        result = simulator.run(circuit, repetitions=500)
        measurements = result.measurements['result']
        energy = min(evaluate_energy(bitstring) for bitstring in measurements)
        if energy < best_energy:
            best_energy = energy
            best_solution = tuple(measurements[np.argmin([evaluate_energy(b) for b in measurements])])
        return energy
    initial_params = np.random.uniform(0, np.pi, 2 * p)
    result = minimize(objective, initial_params, method='COBYLA', options={'maxiter': 20})
    return {i: int(bit) for i, bit in enumerate(best_solution)} if best_solution else {i: 0 for i in range(num_vars)}

# Redistribute cars with QAOA (Fixed)
def redistribute_cars_with_qaoa(routes, congested_segments, p=1):
    print("Redistributing cars with QAOA...")
    n_alts = 3
    n_cars = len(routes)
    var_map = {(car_id, alt_id): car_id * n_alts + alt_id for car_id in routes for alt_id in range(n_alts)}
    Q, _ = formulate_qubo(routes, congested_segments)
    final_routes = {}

    # Dynamically create groups based on n_cars, with a max group size of 6
    group_size = 6
    groups = [range(i, min(i + group_size, n_cars)) for i in range(0, n_cars, group_size)]

    for group in groups:
        subset_routes = {car_id: routes[car_id] for car_id in group if car_id in routes}
        if not subset_routes:  # Skip empty groups
            continue
        subset_var_map = {(car_id, alt_id): var_map[(car_id, alt_id)] for car_id in subset_routes for alt_id in range(n_alts)}
        subset_vars = list(subset_var_map.values())
        Q_subset = Q[np.ix_(subset_vars, subset_vars)]
        solution = solve_qaoa_with_cirq(Q_subset, len(subset_var_map), p)
        for car_id in subset_routes:
            for alt_id in range(min(n_alts, len(routes[car_id]))):
                if solution.get(subset_var_map[(car_id, alt_id)], 0) == 1:
                    final_routes[car_id] = [routes[car_id][alt_id]]
                    break
            if car_id not in final_routes and routes[car_id]:
                final_routes[car_id] = [routes[car_id][0]]
    return final_routes

# Compute signal timings
def compute_signal_timings(G, critical_data, routes_before, routes_after=None):
    print("Computing signal timings with directions...")
    signal_timings = {}
    max_cycle = 120
    critical_intersections, signal_directions = critical_data
    for node in critical_intersections:
        routes_to_use = routes_after if routes_after else routes_before
        before_count = sum(1 for paths in routes_before.values() for u, v in paths[0] if u == node or v == node)
        after_count = sum(1 for paths in routes_to_use.values() for u, v in paths[0] if u == node or v == node)
        green = min(60, max(20, after_count * 2)) if after_count > 0 else max(20, before_count * 1.5)
        red = max_cycle - green - 5
        signal_timings[node] = {
            'green': green,
            'yellow': 5,
            'red': red,
            'coords': (G.nodes[node]['y'], G.nodes[node]['x']),
            'directions': signal_directions.get(node, [])
        }
        print(f"Traffic Signal @ Node {node}: Green={green}s, Red={red}s, Directions={', '.join(signal_directions.get(node, []))}")
    return signal_timings

# Visualize before optimization
def visualize_before(G, original_routes, congested_segments, critical_intersections, signal_directions):
    print("Visualizing before optimization...")
    m = folium.Map(location=(40.7558, -73.9864), zoom_start=15)
    color_list = list(mcolors.TABLEAU_COLORS.values()) + list(mcolors.CSS4_COLORS.values())[:24]  # Extended for 24 cars
    unique_colors = color_list[:len(original_routes)]
    for (u, v), count in congested_segments.items():
        if u in G.nodes and v in G.nodes and G.has_edge(u, v):
            coords = [(G.nodes[u]['y'], G.nodes[u]['x']), (G.nodes[v]['y'], G.nodes[v]['x'])]
            folium.PolyLine(coords, color='red', weight=8, opacity=0.8, tooltip=f'Jam: {count} cars').add_to(m)
            folium.Marker(coords[0], icon=folium.Icon(color='red', icon='exclamation-triangle', prefix='fa')).add_to(m)
    for car_id, path in original_routes.items():
        if path and path[0]:
            points = [(G.nodes[u]['y'], G.nodes[u]['x']) for u, v in path[0] if u in G.nodes and v in G.nodes and G.has_edge(u, v)]
            if len(points) >= 2:
                unique_points = list(dict.fromkeys(points))
                car_color = unique_colors[car_id % len(unique_colors)]
                folium.PolyLine(unique_points, color=car_color, weight=4, tooltip=f'Car {car_id}').add_to(m)
                folium.Marker(unique_points[0], icon=folium.Icon(color='blue', icon='car', prefix='fa')).add_to(m)
                folium.Marker(unique_points[-1], icon=folium.Icon(color='red', icon='flag-checkered', prefix='fa')).add_to(m)
    signal_timings = compute_signal_timings(G, (critical_intersections, signal_directions), original_routes)
    for node, timings in signal_timings.items():
        directions_str = ", ".join(timings['directions']) if timings['directions'] else "All directions"
        folium.Marker(
            timings['coords'],
            icon=folium.Icon(color='orange', icon='traffic-light', prefix='fa', icon_size=(30, 30)),
            tooltip=f"Traffic Signal @ Node {node}: Green={timings['green']}s, Red={timings['red']}s, Directions={directions_str}"
        ).add_to(m)
        folium.Circle(timings['coords'], radius=20, color='orange', fill=True, fill_opacity=0.4).add_to(m)
    m.get_root().html.add_child(folium.Element(legend_html))
    return m

# Visualize after optimization
def visualize_after_with_signals(G, optimized_routes, congested_segments, signal_timings):
    print("Visualizing after optimization with enhanced traffic signals...")
    m = folium.Map(location=(40.7558, -73.9864), zoom_start=15)
    for (u, v), count in congested_segments.items():
        if u in G.nodes and v in G.nodes:
            coords = [(G.nodes[u]['y'], G.nodes[u]['x']), (G.nodes[v]['y'], G.nodes[v]['x'])]
            folium.PolyLine(coords, color='red', weight=8, opacity=0.5, tooltip=f'Jam: {count} cars').add_to(m)
            folium.Marker(coords[0], icon=folium.Icon(color='red', icon='exclamation-triangle', prefix='fa')).add_to(m)
    for car_id, paths in optimized_routes.items():
        if paths and paths[0]:
            points = [(G.nodes[u]['y'], G.nodes[u]['x']) for u, v in paths[0] if u in G.nodes and v in G.nodes]
            if len(points) >= 2:
                unique_points = list(dict.fromkeys(points))
                folium.PolyLine(unique_points, color='green', weight=4, dash_array='5', tooltip=f'Car {car_id}').add_to(m)
                folium.Marker(unique_points[0], icon=folium.Icon(color='green', icon='car', prefix='fa')).add_to(m)
                folium.Marker(unique_points[-1], icon=folium.Icon(color='darkgreen', icon='flag-checkered', prefix='fa')).add_to(m)
    for node, timings in signal_timings.items():
        directions_str = ", ".join(timings['directions']) if timings['directions'] else "All directions"
        folium.Marker(
            timings['coords'],
            icon=folium.Icon(color='orange', icon='traffic-light', prefix='fa', icon_size=(30, 30)),
            tooltip=f"Traffic Signal @ Node {node}: Green={timings['green']}s, Red={timings['red']}s, Directions={directions_str}"
        ).add_to(m)
        folium.Circle(timings['coords'], radius=20, color='orange', fill=True, fill_opacity=0.4).add_to(m)
    m.get_root().html.add_child(folium.Element(legend_html))
    return m

# UI and Main Logic
G = load_map()  # Load map once

# Widgets
n_cars_dropdown = widgets.Dropdown(options=[6, 12, 18, 24], value=18, description='Number of Cars:')
run_button = widgets.Button(description="Run Optimization")
output_before = Output()
output_after = Output()

# Tab layout for outputs
tab = Tab(children=[output_before, output_after])
tab.set_title(0, 'Before Optimization')
tab.set_title(1, 'After Optimization')

# Event handler for Run Optimization
def on_run_button_clicked(b):
    with output_before:
        output_before.clear_output()
        congested_segments, original_routes = generate_synthetic_routes(G, n_cars=n_cars_dropdown.value)
        critical_intersections, signal_directions = identify_critical_intersections(G, congested_segments, original_routes)
        map_before = visualize_before(G, original_routes, congested_segments, critical_intersections, signal_directions)
        display.display(map_before)
        map_before.save("map_before.html")
        print("Before map saved as 'map_before.html'")

    with output_after:
        output_after.clear_output()
        optimized_routes = find_alternative_routes(G, original_routes, congested_segments)
        final_routes = redistribute_cars_with_qaoa(optimized_routes, congested_segments, p=1)
        signal_timings = compute_signal_timings(G, (critical_intersections, signal_directions), original_routes, final_routes)
        map_after = visualize_after_with_signals(G, final_routes, congested_segments, signal_timings)
        display.display(map_after)
        map_after.save("map_after_with_signals.html")
        print("After map saved as 'map_after_with_signals.html'")

    gc.collect()

run_button.on_click(on_run_button_clicked)

# Display UI
display.display(VBox([n_cars_dropdown, run_button, tab]))

print("UI loaded. Select the number of cars and click 'Run Optimization' to see both Before and After results.")

# Install required packages if not already installed
!pip install osmnx folium cirq ipywidgets numpy matplotlib IPython -q

import osmnx as ox
import networkx as nx
from collections import defaultdict
import folium
import cirq
import numpy as np
from scipy.optimize import minimize
import IPython.display as display
from itertools import combinations
import gc
import matplotlib.colors as mcolors
import ipywidgets as widgets
from ipywidgets import Output, VBox, Tab

# Updated legend with traffic signal entry
legend_html = """
<div style="position: fixed; bottom: 50px; right: 50px; width: 180px; height: 260px;
            background-color: white; border:2px solid grey; z-index:9999; font-size:14px;">
 <b>Traffic Map Legend</b> <br>
 <i class="fa fa-exclamation-triangle fa-1x" style="color:red"></i> Traffic Jam <br>
 <span style="color:purple">Unique Colors</span> Car Routes (Before) <br>
 <i class="fa fa-car fa-1x" style="color:blue"></i> Car Start (Before) <br>
 <i class="fa fa-flag-checkered fa-1x" style="color:red"></i> Car End (Before) <br>
 <i class="fa fa-car fa-1x" style="color:green"></i> Car Start (After) <br>
 <i class="fa fa-flag-checkered fa-1x" style="color:darkgreen"></i> Car End (After) <br>
 <span style="color:green">Green Line</span> Smarter Route (After) <br>
 <i class="fa fa-traffic-light fa-1x" style="color:orange"></i> Traffic Signal <br>
</div>
"""

# Load graph for Times Square
def load_map():
    print("Loading map data for Times Square...")
    G = ox.graph_from_point((40.7558, -73.9864), dist=300, network_type='drive', simplify=False)
    ox.distance.add_edge_lengths(G)
    print(f"Graph loaded with {len(G.nodes)} nodes and {len(G.edges)} edges")
    return G

# Generate synthetic routes with forced congestion
def generate_synthetic_routes(G, n_cars=18):
    print(f"Generating {n_cars} synthetic routes...")
    nodes = list(G.nodes)
    if len(nodes) < 5:
        raise ValueError("Graph too small")
    original_routes = {}
    # Use all nodes instead of just the first 20 to ensure variety
    for car_id in range(n_cars):
        start = nodes[car_id % len(nodes)]
        mid = nodes[(car_id + 1) % len(nodes)]
        end = nodes[(car_id + 2) % len(nodes)]
        try:
            path1 = nx.shortest_path(G, start, mid, weight='length')
            path2 = nx.shortest_path(G, mid, end, weight='length')
            route = path1[:-1] + path2  # Combine paths
            edges = list(zip(route, route[1:]))
            if edges:  # Only add if the route has edges
                original_routes[car_id] = [edges]
            else:
                print(f"Warning: Empty route for car {car_id}")
        except nx.NetworkXNoPath:
            print(f"Warning: No path for car {car_id}, using fallback edge")
            edge = [(start, mid)] if G.has_edge(start, mid) else [(nodes[0], nodes[1])]
            original_routes[car_id] = [edge]
    segment_counts = defaultdict(int)
    for paths in original_routes.values():
        for u, v in paths[0]:
            segment_counts[(u, v)] += 1
    congested_segments = {seg: count for seg, count in segment_counts.items() if count >= 4}
    print(f"Generated {len(original_routes)} routes, Congested segments: {len(congested_segments)}")
    return congested_segments, original_routes

# Identify critical intersections
def identify_critical_intersections(G, congested_segments, original_routes, min_distance=80):
    print("Identifying critical intersections based on congestion...")
    intersection_load = defaultdict(int)
    critical_intersections = {}
    signal_coords = []
    signal_directions = {}
    for (u, v), count in congested_segments.items():
        if G.has_edge(u, v) or G.has_edge(v, u):
            if u in G.nodes and v in G.nodes:
                intersection_load[u] += count
                intersection_load[v] += count
    for paths in original_routes.values():
        for u, v in paths[0]:
            if u in G.nodes and v in G.nodes and G.has_edge(u, v):
                if (u, v) in congested_segments or (v, u) in congested_segments:
                    intersection_load[u] += 1
                    intersection_load[v] += 1
    considered_nodes = set()
    for (u, v), _ in congested_segments.items():
        if G.has_edge(u, v) or G.has_edge(v, u):
            for node in [u, v]:
                if node in G.nodes and node not in considered_nodes:
                    considered_nodes.add(node)
                    lat1, lon1 = G.nodes[node]['y'], G.nodes[node]['x']
                    too_close_node = any(ox.distance.great_circle(lat1, lon1, lat, lon) < min_distance
                                       for lat, lon in signal_coords)
                    too_close_segment = any(G.has_edge(node, existing_node)
                                          for existing_node in critical_intersections)
                    if not (too_close_node or too_close_segment):
                        critical_intersections[node] = intersection_load[node]
                        signal_coords.append((lat1, lon1))
                        signal_directions[node] = determine_directions(G, node)
    for node in G.nodes:
        if node not in considered_nodes:
            lat1, lon1 = G.nodes[node]['y'], G.nodes[node]['x']
            close_to_congestion = any(ox.distance.great_circle(lat1, lon1, G.nodes[u]['y'], G.nodes[u]['x']) < 20
                                    or ox.distance.great_circle(lat1, lon1, G.nodes[v]['y'], G.nodes[v]['x']) < 20
                                    for u, v in congested_segments.keys() if G.has_edge(u, v) or G.has_edge(v, u))
            if close_to_congestion:
                too_close_node = any(ox.distance.great_circle(lat1, lon1, lat, lon) < min_distance
                                   for lat, lon in signal_coords)
                too_close_segment = any(G.has_edge(node, existing_node)
                                      for existing_node in critical_intersections)
                if not (too_close_node or too_close_segment):
                    critical_intersections[node] = intersection_load.get(node, 0)
                    signal_coords.append((lat1, lon1))
                    signal_directions[node] = determine_directions(G, node)
    print(f"Critical intersections: {len(critical_intersections)}")
    return critical_intersections, signal_directions

def determine_directions(G, node):
    directions = []
    if node not in G.nodes:
        return directions
    edges = [(u, v) for u, v in G.edges(node) if u == node or v == node]
    for u, v in edges:
        if u == node:
            lat1, lon1 = G.nodes[u]['y'], G.nodes[u]['x']
            lat2, lon2 = G.nodes[v]['y'], G.nodes[v]['x']
        else:
            lat1, lon1 = G.nodes[v]['y'], G.nodes[v]['x']
            lat2, lon2 = G.nodes[u]['y'], G.nodes[u]['x']
        delta_lon = lon2 - lon1
        delta_lat = lat2 - lat1
        angle = np.degrees(np.arctan2(delta_lon, delta_lat))
        if angle < 0:
            angle += 360
        if 315 <= angle or angle < 45:
            direction = "Northbound"
        elif 45 <= angle < 135:
            direction = "Eastbound"
        elif 135 <= angle < 225:
            direction = "Southbound"
        else:
            direction = "Westbound"
        directions.append(direction)
    return sorted(list(set(directions)))

# Find alternative routes
def find_alternative_routes(G, routes, congested_segments, max_alts=3):
    print("Finding alternative routes...")
    G_simple = nx.Graph(G) if G.is_multigraph() else G
    car_routes = {}
    for car_id, paths in routes.items():
        if not paths or not paths[0]:
            car_routes[car_id] = [[(list(G.nodes)[0], list(G.nodes)[1])]]
            print(f"Warning: Car {car_id} had no initial path, using fallback")
            continue
        source, dest = paths[0][0][0], paths[0][-1][1]
        alts = []
        try:
            for path in nx.shortest_simple_paths(G_simple, source, dest, weight='length'):
                if len(alts) >= max_alts: break
                path_edges = list(zip(path, path[1:]))
                if path_edges and path_edges not in alts:
                    alts.append(path_edges)
            if not alts: raise nx.NetworkXNoPath
        except nx.NetworkXNoPath:
            print(f"Warning: No alternative path for car {car_id}, keeping original")
            alts = [paths[0]]
        car_routes[car_id] = alts[:max_alts]
    print(f"Generated alternative routes for {len(car_routes)} cars")
    return car_routes

# Formulate QUBO
def formulate_qubo(routes, congested_segments, penalty=100):
    print("Formulating QUBO...")
    n_cars = len(routes)
    n_alts = 3
    n_vars = n_cars * n_alts
    var_map = {(car_id, alt_id): car_id * n_alts + alt_id for car_id in routes for alt_id in range(n_alts)}
    Q = np.zeros((n_vars, n_vars))
    segment_usage = defaultdict(list)
    for car_id, alts in routes.items():
        for alt_id in range(min(n_alts, len(alts))):
            idx = var_map[(car_id, alt_id)]
            for u, v in alts[alt_id]:
                segment_usage[(u, v)].append(idx)
    for _, indices in segment_usage.items():
        for idx in indices: Q[idx, idx] += 1
        for i, j in combinations(indices, 2):
            Q[i, j] += 2; Q[j, i] += 2
    for car_id in routes:
        indices = [var_map[(car_id, j)] for j in range(min(n_alts, len(routes[car_id])))]
        for idx in indices: Q[idx, idx] -= penalty
        for i, j in combinations(indices, 2):
            Q[i, j] += 2 * penalty; Q[j, i] += 2 * penalty
    return Q, var_map

# Solve QAOA with Cirq
def solve_qaoa_with_cirq(Q, num_vars, p=1):
    print(f"Solving QAOA with {num_vars} variables, p={p}...")
    if num_vars == 0:
        print("No variables to optimize; skipping QAOA.")
        return {}
    qubits = [cirq.LineQubit(i) for i in range(num_vars)]
    simulator = cirq.Simulator()
    best_solution = None
    best_energy = float('inf')
    def evaluate_energy(bitstring):
        return sum(Q[i, j] * bitstring[i] * bitstring[j] for i in range(num_vars) for j in range(num_vars))
    def create_qaoa_circuit(gamma, beta):
        circuit = cirq.Circuit()
        circuit.append(cirq.H.on_each(*qubits))
        for layer in range(p):
            for i in range(num_vars):
                if abs(Q[i, i]) > 1e-6:
                    circuit.append(cirq.rz(2 * gamma[layer] * Q[i, i]).on(qubits[i]))
                for j in range(i + 1, num_vars):
                    if abs(Q[i, j]) > 1e-6:
                        circuit.append(cirq.CNOT(qubits[i], qubits[j]))
                        circuit.append(cirq.rz(2 * gamma[layer] * Q[i, j]).on(qubits[j]))
                        circuit.append(cirq.CNOT(qubits[i], qubits[j]))
            circuit.append(cirq.rx(2 * beta[layer]).on_each(*qubits))
        circuit.append(cirq.measure(*qubits, key='result'))
        return circuit
    def objective(params):
        nonlocal best_solution, best_energy
        gamma = params[:p]
        beta = params[p:]
        circuit = create_qaoa_circuit(gamma, beta)
        result = simulator.run(circuit, repetitions=500)
        measurements = result.measurements['result']
        energy = min(evaluate_energy(bitstring) for bitstring in measurements)
        if energy < best_energy:
            best_energy = energy
            best_solution = tuple(measurements[np.argmin([evaluate_energy(b) for b in measurements])])
        return energy
    initial_params = np.random.uniform(0, np.pi, 2 * p)
    result = minimize(objective, initial_params, method='COBYLA', options={'maxiter': 20})
    return {i: int(bit) for i, bit in enumerate(best_solution)} if best_solution else {i: 0 for i in range(num_vars)}

# Redistribute cars with QAOA
def redistribute_cars_with_qaoa(routes, congested_segments, p=1):
    print("Redistributing cars with QAOA...")
    n_alts = 3
    n_cars = len(routes)
    var_map = {(car_id, alt_id): car_id * n_alts + alt_id for car_id in routes for alt_id in range(n_alts)}
    Q, _ = formulate_qubo(routes, congested_segments)
    final_routes = {}
    group_size = 6
    groups = [range(i, min(i + group_size, n_cars)) for i in range(0, n_cars, group_size)]
    for group in groups:
        subset_routes = {car_id: routes[car_id] for car_id in group if car_id in routes}
        if not subset_routes:
            continue
        subset_var_map = {(car_id, alt_id): var_map[(car_id, alt_id)] for car_id in subset_routes for alt_id in range(n_alts)}
        subset_vars = list(subset_var_map.values())
        Q_subset = Q[np.ix_(subset_vars, subset_vars)]
        solution = solve_qaoa_with_cirq(Q_subset, len(subset_var_map), p)
        for car_id in subset_routes:
            assigned = False
            for alt_id in range(min(n_alts, len(routes[car_id]))):
                if solution.get(subset_var_map[(car_id, alt_id)], 0) == 1:
                    final_routes[car_id] = [routes[car_id][alt_id]]
                    assigned = True
                    break
            if not assigned and routes[car_id]:
                final_routes[car_id] = [routes[car_id][0]]  # Fallback to first route
    print(f"Optimized routes for {len(final_routes)} cars")
    return final_routes

# Compute signal timings
def compute_signal_timings(G, critical_data, routes_before, routes_after=None):
    print("Computing signal timings with directions...")
    signal_timings = {}
    max_cycle = 120
    critical_intersections, signal_directions = critical_data
    for node in critical_intersections:
        routes_to_use = routes_after if routes_after else routes_before
        before_count = sum(1 for paths in routes_before.values() for u, v in paths[0] if u == node or v == node)
        after_count = sum(1 for paths in routes_to_use.values() for u, v in paths[0] if u == node or v == node)
        green = min(60, max(20, after_count * 2)) if after_count > 0 else max(20, before_count * 1.5)
        red = max_cycle - green - 5
        signal_timings[node] = {
            'green': green,
            'yellow': 5,
            'red': red,
            'coords': (G.nodes[node]['y'], G.nodes[node]['x']),
            'directions': signal_directions.get(node, [])
        }
        print(f"Traffic Signal @ Node {node}: Green={green}s, Red={red}s, Directions={', '.join(signal_directions.get(node, []))}")
    return signal_timings

# Visualize before optimization
def visualize_before(G, original_routes, congested_segments, critical_intersections, signal_directions):
    print("Visualizing before optimization...")
    m = folium.Map(location=(40.7558, -73.9864), zoom_start=15)
    color_list = list(mcolors.TABLEAU_COLORS.values()) + list(mcolors.CSS4_COLORS.values())[:24]
    unique_colors = color_list[:len(original_routes)]
    for (u, v), count in congested_segments.items():
        if u in G.nodes and v in G.nodes and G.has_edge(u, v):
            coords = [(G.nodes[u]['y'], G.nodes[u]['x']), (G.nodes[v]['y'], G.nodes[v]['x'])]
            folium.PolyLine(coords, color='red', weight=8, opacity=0.8, tooltip=f'Jam: {count} cars').add_to(m)
            folium.Marker(coords[0], icon=folium.Icon(color='red', icon='exclamation-triangle', prefix='fa')).add_to(m)
    visualized_cars = 0
    for car_id, path in original_routes.items():
        if path and path[0]:
            points = [(G.nodes[u]['y'], G.nodes[u]['x']) for u, v in path[0] if u in G.nodes and v in G.nodes and G.has_edge(u, v)]
            if points:  # Allow single-point routes to show start marker
                unique_points = list(dict.fromkeys(points))
                car_color = unique_colors[car_id % len(unique_colors)]
                folium.PolyLine(unique_points, color=car_color, weight=4, tooltip=f'Car {car_id}').add_to(m)
                folium.Marker(unique_points[0], icon=folium.Icon(color='blue', icon='car', prefix='fa')).add_to(m)
                if len(unique_points) > 1:
                    folium.Marker(unique_points[-1], icon=folium.Icon(color='red', icon='flag-checkered', prefix='fa')).add_to(m)
                visualized_cars += 1
            else:
                print(f"Warning: No valid points for car {car_id} in Before visualization")
    signal_timings = compute_signal_timings(G, (critical_intersections, signal_directions), original_routes)
    for node, timings in signal_timings.items():
        directions_str = ", ".join(timings['directions']) if timings['directions'] else "All directions"
        folium.Marker(
            timings['coords'],
            icon=folium.Icon(color='orange', icon='traffic-light', prefix='fa', icon_size=(30, 30)),
            tooltip=f"Traffic Signal @ Node {node}: Green={timings['green']}s, Red={timings['red']}s, Directions={directions_str}"
        ).add_to(m)
        folium.Circle(timings['coords'], radius=20, color='orange', fill=True, fill_opacity=0.4).add_to(m)
    m.get_root().html.add_child(folium.Element(legend_html))
    print(f"Visualized {visualized_cars} cars in Before map")
    return m

# Visualize after optimization
def visualize_after_with_signals(G, optimized_routes, congested_segments, signal_timings):
    print("Visualizing after optimization with enhanced traffic signals...")
    m = folium.Map(location=(40.7558, -73.9864), zoom_start=15)
    for (u, v), count in congested_segments.items():
        if u in G.nodes and v in G.nodes:
            coords = [(G.nodes[u]['y'], G.nodes[u]['x']), (G.nodes[v]['y'], G.nodes[v]['x'])]
            folium.PolyLine(coords, color='red', weight=8, opacity=0.5, tooltip=f'Jam: {count} cars').add_to(m)
            folium.Marker(coords[0], icon=folium.Icon(color='red', icon='exclamation-triangle', prefix='fa')).add_to(m)
    visualized_cars = 0
    for car_id, paths in optimized_routes.items():
        if paths and paths[0]:
            points = [(G.nodes[u]['y'], G.nodes[u]['x']) for u, v in paths[0] if u in G.nodes and v in G.nodes]
            if points:  # Allow single-point routes to show start marker
                unique_points = list(dict.fromkeys(points))
                folium.PolyLine(unique_points, color='green', weight=4, dash_array='5', tooltip=f'Car {car_id}').add_to(m)
                folium.Marker(unique_points[0], icon=folium.Icon(color='green', icon='car', prefix='fa')).add_to(m)
                if len(unique_points) > 1:
                    folium.Marker(unique_points[-1], icon=folium.Icon(color='darkgreen', icon='flag-checkered', prefix='fa')).add_to(m)
                visualized_cars += 1
            else:
                print(f"Warning: No valid points for car {car_id} in After visualization")
    for node, timings in signal_timings.items():
        directions_str = ", ".join(timings['directions']) if timings['directions'] else "All directions"
        folium.Marker(
            timings['coords'],
            icon=folium.Icon(color='orange', icon='traffic-light', prefix='fa', icon_size=(30, 30)),
            tooltip=f"Traffic Signal @ Node {node}: Green={timings['green']}s, Red={timings['red']}s, Directions={directions_str}"
        ).add_to(m)
        folium.Circle(timings['coords'], radius=20, color='orange', fill=True, fill_opacity=0.4).add_to(m)
    m.get_root().html.add_child(folium.Element(legend_html))
    print(f"Visualized {visualized_cars} cars in After map")
    return m

# UI and Main Logic
G = load_map()  # Load map once

# Widgets
n_cars_dropdown = widgets.Dropdown(options=[6, 12, 18, 24], value=18, description='Number of Cars:')
run_button = widgets.Button(description="Run Optimization")
output_before = Output()
output_after = Output()

# Tab layout for outputs
tab = Tab(children=[output_before, output_after])
tab.set_title(0, 'Before Optimization')
tab.set_title(1, 'After Optimization')

# Event handler for Run Optimization
def on_run_button_clicked(b):
    with output_before:
        output_before.clear_output()
        congested_segments, original_routes = generate_synthetic_routes(G, n_cars=n_cars_dropdown.value)
        critical_intersections, signal_directions = identify_critical_intersections(G, congested_segments, original_routes)
        map_before = visualize_before(G, original_routes, congested_segments, critical_intersections, signal_directions)
        display.display(map_before)
        map_before.save("map_before.html")
        print("Before map saved as 'map_before.html'")

    with output_after:
        output_after.clear_output()
        optimized_routes = find_alternative_routes(G, original_routes, congested_segments)
        final_routes = redistribute_cars_with_qaoa(optimized_routes, congested_segments, p=1)
        signal_timings = compute_signal_timings(G, (critical_intersections, signal_directions), original_routes, final_routes)
        map_after = visualize_after_with_signals(G, final_routes, congested_segments, signal_timings)
        display.display(map_after)
        map_after.save("map_after_with_signals.html")
        print("After map saved as 'map_after_with_signals.html'")

    gc.collect()

run_button.on_click(on_run_button_clicked)

# Display UI
display.display(VBox([n_cars_dropdown, run_button, tab]))

print("UI loaded. Select the number of cars and click 'Run Optimization' to see both Before and After results.")

# Install required packages if not already installed
!pip install osmnx folium cirq ipywidgets numpy matplotlib IPython -q

import osmnx as ox
import networkx as nx
from collections import defaultdict
import folium
import cirq
import numpy as np
from scipy.optimize import minimize
import IPython.display as display
from itertools import combinations
import gc
import matplotlib.colors as mcolors
import ipywidgets as widgets
from ipywidgets import Output, VBox, Tab
import random

# Updated legend with traffic signal entry
legend_html = """
<div style="position: fixed; bottom: 50px; right: 50px; width: 180px; height: 260px;
            background-color: white; border:2px solid grey; z-index:9999; font-size:14px;">
 <b>Traffic Map Legend</b> <br>
 <i class="fa fa-exclamation-triangle fa-1x" style="color:red"></i> Traffic Jam <br>
 <span style="color:purple">Unique Colors</span> Car Routes (Before) <br>
 <i class="fa fa-car fa-1x" style="color:blue"></i> Car Start (Before) <br>
 <i class="fa fa-flag-checkered fa-1x" style="color:red"></i> Car End (Before) <br>
 <i class="fa fa-car fa-1x" style="color:green"></i> Car Start (After) <br>
 <i class="fa fa-flag-checkered fa-1x" style="color:darkgreen"></i> Car End (After) <br>
 <span style="color:green">Green Line</span> Smarter Route (After) <br>
 <i class="fa fa-traffic-light fa-1x" style="color:orange"></i> Traffic Signal <br>
</div>
"""

# Load graph for Times Square
def load_map():
    print("Loading map data for Times Square...")
    G = ox.graph_from_point((40.7558, -73.9864), dist=300, network_type='drive', simplify=False)
    ox.distance.add_edge_lengths(G)
    print(f"Graph loaded with {len(G.nodes)} nodes and {len(G.edges)} edges")
    return G

# Generate synthetic routes with forced congestion
def generate_synthetic_routes(G, n_cars=6):
    print(f"Generating {n_cars} synthetic routes...")
    nodes = list(G.nodes)
    if len(nodes) < 3:
        raise ValueError("Graph too small")
    original_routes = {}
    for car_id in range(n_cars):
        start, mid, end = random.sample(nodes, 3)
        try:
            path1 = nx.shortest_path(G, start, mid, weight='length')
            path2 = nx.shortest_path(G, mid, end, weight='length')
            route = path1[:-1] + path2
            edges = list(zip(route, route[1:]))
            original_routes[car_id] = [edges]
        except nx.NetworkXNoPath:
            print(f"Warning: No path for car {car_id}, using fallback single edge")
            edge = [(start, mid)] if G.has_edge(start, mid) else random.choice(list(G.edges()))
            original_routes[car_id] = [[edge]]
    segment_counts = defaultdict(int)
    for paths in original_routes.values():
        for u, v in paths[0]:
            segment_counts[(u, v)] += 1
    congested_segments = {seg: count for seg, count in segment_counts.items() if count >= 2}  # Adjusted for smaller n_cars
    print(f"Generated routes for {len(original_routes)} cars, Congested segments: {len(congested_segments)}")
    return congested_segments, original_routes

# Identify critical intersections
def identify_critical_intersections(G, congested_segments, original_routes, min_distance=80):
    print("Identifying critical intersections based on congestion...")
    intersection_load = defaultdict(int)
    critical_intersections = {}
    signal_coords = []
    signal_directions = {}
    for (u, v), count in congested_segments.items():
        if G.has_edge(u, v) or G.has_edge(v, u):
            if u in G.nodes and v in G.nodes:
                intersection_load[u] += count
                intersection_load[v] += count
    for paths in original_routes.values():
        for u, v in paths[0]:
            if u in G.nodes and v in G.nodes and G.has_edge(u, v):
                if (u, v) in congested_segments or (v, u) in congested_segments:
                    intersection_load[u] += 1
                    intersection_load[v] += 1
    considered_nodes = set()
    for (u, v), _ in congested_segments.items():
        if G.has_edge(u, v) or G.has_edge(v, u):
            for node in [u, v]:
                if node in G.nodes and node not in considered_nodes:
                    considered_nodes.add(node)
                    lat1, lon1 = G.nodes[node]['y'], G.nodes[node]['x']
                    too_close_node = any(ox.distance.great_circle(lat1, lon1, lat, lon) < min_distance
                                       for lat, lon in signal_coords)
                    too_close_segment = any(G.has_edge(node, existing_node)
                                          for existing_node in critical_intersections)
                    if not (too_close_node or too_close_segment):
                        critical_intersections[node] = intersection_load[node]
                        signal_coords.append((lat1, lon1))
                        signal_directions[node] = determine_directions(G, node)
    for node in G.nodes:
        if node not in considered_nodes:
            lat1, lon1 = G.nodes[node]['y'], G.nodes[node]['x']
            close_to_congestion = any(ox.distance.great_circle(lat1, lon1, G.nodes[u]['y'], G.nodes[u]['x']) < 20
                                    or ox.distance.great_circle(lat1, lon1, G.nodes[v]['y'], G.nodes[v]['x']) < 20
                                    for u, v in congested_segments.keys() if G.has_edge(u, v) or G.has_edge(v, u))
            if close_to_congestion:
                too_close_node = any(ox.distance.great_circle(lat1, lon1, lat, lon) < min_distance
                                   for lat, lon in signal_coords)
                too_close_segment = any(G.has_edge(node, existing_node)
                                      for existing_node in critical_intersections)
                if not (too_close_node or too_close_segment):
                    critical_intersections[node] = intersection_load.get(node, 0)
                    signal_coords.append((lat1, lon1))
                    signal_directions[node] = determine_directions(G, node)
    print(f"Critical intersections: {len(critical_intersections)}")
    return critical_intersections, signal_directions

def determine_directions(G, node):
    directions = []
    if node not in G.nodes:
        return directions
    edges = [(u, v) for u, v in G.edges(node) if u == node or v == node]
    for u, v in edges:
        if u == node:
            lat1, lon1 = G.nodes[u]['y'], G.nodes[u]['x']
            lat2, lon2 = G.nodes[v]['y'], G.nodes[v]['x']
        else:
            lat1, lon1 = G.nodes[v]['y'], G.nodes[v]['x']
            lat2, lon2 = G.nodes[u]['y'], G.nodes[u]['x']
        delta_lon = lon2 - lon1
        delta_lat = lat2 - lat1
        angle = np.degrees(np.arctan2(delta_lon, delta_lat))
        if angle < 0:
            angle += 360
        if 315 <= angle or angle < 45:
            direction = "Northbound"
        elif 45 <= angle < 135:
            direction = "Eastbound"
        elif 135 <= angle < 225:
            direction = "Southbound"
        else:
            direction = "Westbound"
        directions.append(direction)
    return sorted(list(set(directions)))

# Find alternative routes
def find_alternative_routes(G, routes, congested_segments, max_alts=3):
    print("Finding alternative routes...")
    G_simple = nx.Graph(G) if G.is_multigraph() else G
    car_routes = {}
    for car_id, paths in routes.items():
        if not paths or not paths[0]:
            print(f"Warning: Car {car_id} had no initial path, using fallback")
            edge = random.choice(list(G.edges()))
            car_routes[car_id] = [[[edge]]]
            continue
        source, dest = paths[0][0][0], paths[0][-1][1]
        alts = []
        try:
            for path in nx.shortest_simple_paths(G_simple, source, dest, weight='length'):
                if len(alts) >= max_alts: break
                path_edges = list(zip(path, path[1:]))
                if path_edges and path_edges not in alts:
                    alts.append(path_edges)
            if not alts: raise nx.NetworkXNoPath
        except nx.NetworkXNoPath:
            print(f"Warning: No alternative path for car {car_id}, keeping original")
            alts = [paths[0]]
        car_routes[car_id] = alts[:max_alts]
    print(f"Generated alternative routes for {len(car_routes)} cars")
    return car_routes

# Formulate QUBO
def formulate_qubo(routes, congested_segments, penalty=100):
    print("Formulating QUBO...")
    n_cars = len(routes)
    n_alts = 3
    n_vars = n_cars * n_alts
    var_map = {(car_id, alt_id): car_id * n_alts + alt_id for car_id in routes for alt_id in range(n_alts)}
    Q = np.zeros((n_vars, n_vars))
    segment_usage = defaultdict(list)
    for car_id, alts in routes.items():
        for alt_id in range(min(n_alts, len(alts))):
            idx = var_map[(car_id, alt_id)]
            for u, v in alts[alt_id]:
                segment_usage[(u, v)].append(idx)
    for _, indices in segment_usage.items():
        for idx in indices: Q[idx, idx] += 1
        for i, j in combinations(indices, 2):
            Q[i, j] += 2; Q[j, i] += 2
    for car_id in routes:
        indices = [var_map[(car_id, j)] for j in range(min(n_alts, len(routes[car_id])))]
        for idx in indices: Q[idx, idx] -= penalty
        for i, j in combinations(indices, 2):
            Q[i, j] += 2 * penalty; Q[j, i] += 2 * penalty
    return Q, var_map

# Solve QAOA with Cirq
def solve_qaoa_with_cirq(Q, num_vars, p=1):
    print(f"Solving QAOA with {num_vars} variables, p={p}...")
    if num_vars == 0:
        print("No variables to optimize; skipping QAOA.")
        return {}
    qubits = [cirq.LineQubit(i) for i in range(num_vars)]
    simulator = cirq.Simulator()
    best_solution = None
    best_energy = float('inf')
    def evaluate_energy(bitstring):
        return sum(Q[i, j] * bitstring[i] * bitstring[j] for i in range(num_vars) for j in range(num_vars))
    def create_qaoa_circuit(gamma, beta):
        circuit = cirq.Circuit()
        circuit.append(cirq.H.on_each(*qubits))
        for layer in range(p):
            for i in range(num_vars):
                if abs(Q[i, i]) > 1e-6:
                    circuit.append(cirq.rz(2 * gamma[layer] * Q[i, i]).on(qubits[i]))
                for j in range(i + 1, num_vars):
                    if abs(Q[i, j]) > 1e-6:
                        circuit.append(cirq.CNOT(qubits[i], qubits[j]))
                        circuit.append(cirq.rz(2 * gamma[layer] * Q[i, j]).on(qubits[j]))
                        circuit.append(cirq.CNOT(qubits[i], qubits[j]))
            circuit.append(cirq.rx(2 * beta[layer]).on_each(*qubits))
        circuit.append(cirq.measure(*qubits, key='result'))
        return circuit
    def objective(params):
        nonlocal best_solution, best_energy
        gamma = params[:p]
        beta = params[p:]
        circuit = create_qaoa_circuit(gamma, beta)
        result = simulator.run(circuit, repetitions=500)
        measurements = result.measurements['result']
        energy = min(evaluate_energy(bitstring) for bitstring in measurements)
        if energy < best_energy:
            best_energy = energy
            best_solution = tuple(measurements[np.argmin([evaluate_energy(b) for b in measurements])])
        return energy
    initial_params = np.random.uniform(0, np.pi, 2 * p)
    result = minimize(objective, initial_params, method='COBYLA', options={'maxiter': 20})
    return {i: int(bit) for i, bit in enumerate(best_solution)} if best_solution else {i: 0 for i in range(num_vars)}

# Redistribute cars with QAOA
def redistribute_cars_with_qaoa(routes, congested_segments, p=1):
    print("Redistributing cars with QAOA...")
    n_alts = 3
    n_cars = len(routes)
    var_map = {(car_id, alt_id): car_id * n_alts + alt_id for car_id in routes for alt_id in range(n_alts)}
    Q, _ = formulate_qubo(routes, congested_segments)
    final_routes = {}
    group_size = 6
    groups = [range(i, min(i + group_size, n_cars)) for i in range(0, n_cars, group_size)]
    for group in groups:
        subset_routes = {car_id: routes[car_id] for car_id in group if car_id in routes}
        if not subset_routes:
            continue
        subset_var_map = {(car_id, alt_id): var_map[(car_id, alt_id)] for car_id in subset_routes for alt_id in range(n_alts)}
        subset_vars = list(subset_var_map.values())
        Q_subset = Q[np.ix_(subset_vars, subset_vars)]
        solution = solve_qaoa_with_cirq(Q_subset, len(subset_var_map), p)
        for car_id in subset_routes:
            assigned = False
            for alt_id in range(min(n_alts, len(routes[car_id]))):
                if solution.get(subset_var_map[(car_id, alt_id)], 0) == 1:
                    final_routes[car_id] = [routes[car_id][alt_id]]
                    assigned = True
                    break
            if not assigned and routes[car_id]:
                final_routes[car_id] = [routes[car_id][0]]
    for car_id in routes:
        if car_id not in final_routes:
            print(f"Warning: Car {car_id} not assigned by QAOA, using original route")
            final_routes[car_id] = [routes[car_id][0]]
    print(f"Optimized routes for {len(final_routes)} cars")
    return final_routes

# Compute signal timings
def compute_signal_timings(G, critical_data, routes_before, routes_after=None):
    print("Computing signal timings with directions...")
    signal_timings = {}
    max_cycle = 120
    critical_intersections, signal_directions = critical_data
    for node in critical_intersections:
        routes_to_use = routes_after if routes_after else routes_before
        before_count = sum(1 for paths in routes_before.values() for u, v in paths[0] if u == node or v == node)
        after_count = sum(1 for paths in routes_to_use.values() for u, v in paths[0] if u == node or v == node)
        green = min(60, max(20, after_count * 2)) if after_count > 0 else max(20, before_count * 1.5)
        red = max_cycle - green - 5
        signal_timings[node] = {
            'green': green,
            'yellow': 5,
            'red': red,
            'coords': (G.nodes[node]['y'], G.nodes[node]['x']),
            'directions': signal_directions.get(node, [])
        }
        print(f"Traffic Signal @ Node {node}: Green={green}s, Red={red}s, Directions={', '.join(signal_directions.get(node, []))}")
    return signal_timings

# Visualize before optimization
def visualize_before(G, original_routes, congested_segments, critical_intersections, signal_directions):
    print("Visualizing before optimization...")
    m = folium.Map(location=(40.7558, -73.9864), zoom_start=15)
    color_list = list(mcolors.TABLEAU_COLORS.values()) + list(mcolors.CSS4_COLORS.values())[:24]
    unique_colors = color_list[:len(original_routes)]
    for (u, v), count in congested_segments.items():
        if u in G.nodes and v in G.nodes and G.has_edge(u, v):
            coords = [(G.nodes[u]['y'], G.nodes[u]['x']), (G.nodes[v]['y'], G.nodes[v]['x'])]
            folium.PolyLine(coords, color='red', weight=8, opacity=0.8, tooltip=f'Jam: {count} cars').add_to(m)
            folium.Marker(coords[0], icon=folium.Icon(color='red', icon='exclamation-triangle', prefix='fa')).add_to(m)
    visualized_cars = 0
    for car_id in range(len(original_routes)):
        path = original_routes.get(car_id, [[]])
        if path and path[0]:
            points = [(G.nodes[u]['y'], G.nodes[u]['x']) for u, v in path[0] if u in G.nodes and v in G.nodes and G.has_edge(u, v)]
            if not points:
                u, v = path[0][0] if path[0] else (list(G.nodes)[0], list(G.nodes)[1])
                points = [(G.nodes[u]['y'], G.nodes[u]['x'])]
                print(f"Warning: Car {car_id} has no valid edges in Before map, using start point")
            unique_points = list(dict.fromkeys(points))
            car_color = unique_colors[car_id % len(unique_colors)]
            print(f"Car {car_id} Before: Plotting {len(unique_points)} points at {unique_points}")
            folium.PolyLine(unique_points, color=car_color, weight=4, tooltip=f'Car {car_id}').add_to(m)
            folium.Marker(unique_points[0], icon=folium.Icon(color='blue', icon='car', prefix='fa'),
                         tooltip=f'Car {car_id} Start').add_to(m)
            end_point = unique_points[-1] if len(unique_points) > 1 else unique_points[0]
            folium.Marker(end_point, icon=folium.Icon(color='red', icon='flag-checkered', prefix='fa'),
                         tooltip=f'Car {car_id} End').add_to(m)
            visualized_cars += 1
        else:
            print(f"Warning: Car {car_id} has no route in Before map, plotting at default location")
            default_point = (G.nodes[list(G.nodes)[0]]['y'], G.nodes[list(G.nodes)[0]]['x'])
            folium.Marker(default_point, icon=folium.Icon(color='blue', icon='car', prefix='fa'),
                         tooltip=f'Car {car_id} Start (No Route)').add_to(m)
            folium.Marker(default_point, icon=folium.Icon(color='red', icon='flag-checkered', prefix='fa'),
                         tooltip=f'Car {car_id} End (No Route)').add_to(m)
            visualized_cars += 1
    signal_timings = compute_signal_timings(G, (critical_intersections, signal_directions), original_routes)
    for node, timings in signal_timings.items():
        directions_str = ", ".join(timings['directions']) if timings['directions'] else "All directions"
        folium.Marker(
            timings['coords'],
            icon=folium.Icon(color='orange', icon='traffic-light', prefix='fa', icon_size=(30, 30)),
            tooltip=f"Traffic Signal @ Node {node}: Green={timings['green']}s, Red={timings['red']}s, Directions={directions_str}"
        ).add_to(m)
        folium.Circle(timings['coords'], radius=20, color='orange', fill=True, fill_opacity=0.4).add_to(m)
    m.get_root().html.add_child(folium.Element(legend_html))
    print(f"Visualized {visualized_cars} cars in Before map")
    return m

# Visualize after optimization
def visualize_after_with_signals(G, optimized_routes, congested_segments, signal_timings):
    print("Visualizing after optimization with enhanced traffic signals...")
    m = folium.Map(location=(40.7558, -73.9864), zoom_start=15)
    for (u, v), count in congested_segments.items():
        if u in G.nodes and v in G.nodes:
            coords = [(G.nodes[u]['y'], G.nodes[u]['x']), (G.nodes[v]['y'], G.nodes[v]['x'])]
            folium.PolyLine(coords, color='red', weight=8, opacity=0.5, tooltip=f'Jam: {count} cars').add_to(m)
            folium.Marker(coords[0], icon=folium.Icon(color='red', icon='exclamation-triangle', prefix='fa')).add_to(m)
    visualized_cars = 0
    for car_id in range(len(optimized_routes)):
        paths = optimized_routes.get(car_id, [[]])
        if paths and paths[0]:
            points = []
            for u, v in paths[0]:
                if u in G.nodes and v in G.nodes:
                    points.append((G.nodes[u]['y'], G.nodes[u]['x']))
                else:
                    print(f"Warning: Invalid node pair ({u}, {v}) for car {car_id} in After map")
            if not points:
                u, v = paths[0][0] if paths[0] else (list(G.nodes)[0], list(G.nodes)[1])
                points = [(G.nodes[u]['y'], G.nodes[u]['x'])]
                print(f"Warning: Car {car_id} has no valid edges in After map, using start point")
            unique_points = list(dict.fromkeys(points))  # Remove duplicates while preserving order
            print(f"Car {car_id} After: Plotting {len(unique_points)} points at {unique_points}")
            folium.PolyLine(unique_points, color='green', weight=4, dash_array='5', tooltip=f'Car {car_id}').add_to(m)
            folium.Marker(unique_points[0], icon=folium.Icon(color='green', icon='car', prefix='fa'),
                         tooltip=f'Car {car_id} Start').add_to(m)
            end_point = unique_points[-1] if len(unique_points) > 1 else unique_points[0]
            folium.Marker(end_point, icon=folium.Icon(color='darkgreen', icon='flag-checkered', prefix='fa'),
                         tooltip=f'Car {car_id} End').add_to(m)
            visualized_cars += 1
        else:
            print(f"Warning: Car {car_id} has no route in After map, plotting at default location")
            default_point = (G.nodes[list(G.nodes)[0]]['y'], G.nodes[list(G.nodes)[0]]['x'])
            folium.Marker(default_point, icon=folium.Icon(color='green', icon='car', prefix='fa'),
                         tooltip=f'Car {car_id} Start (No Route)').add_to(m)
            folium.Marker(default_point, icon=folium.Icon(color='darkgreen', icon='flag-checkered', prefix='fa'),
                         tooltip=f'Car {car_id} End (No Route)').add_to(m)
            visualized_cars += 1
    for node, timings in signal_timings.items():
        directions_str = ", ".join(timings['directions']) if timings['directions'] else "All directions"
        folium.Marker(
            timings['coords'],
            icon=folium.Icon(color='orange', icon='traffic-light', prefix='fa', icon_size=(30, 30)),
            tooltip=f"Traffic Signal @ Node {node}: Green={timings['green']}s, Red={timings['red']}s, Directions={directions_str}"
        ).add_to(m)
        folium.Circle(timings['coords'], radius=20, color='orange', fill=True, fill_opacity=0.4).add_to(m)
    m.get_root().html.add_child(folium.Element(legend_html))
    print(f"Visualized {visualized_cars} cars in After map")
    return m

# UI and Main Logic
G = load_map()  # Load map once

# Widgets
n_cars_dropdown = widgets.Dropdown(options=[6, 12, 18, 24], value=6, description='Number of Cars:')
run_button = widgets.Button(description="Run Optimization")
output_before = Output()
output_after = Output()

# Tab layout for outputs
tab = Tab(children=[output_before, output_after])
tab.set_title(0, 'Before Optimization')
tab.set_title(1, 'After Optimization')

# Event handler for Run Optimization
def on_run_button_clicked(b):
    n_cars = n_cars_dropdown.value
    with output_before:
        output_before.clear_output()
        congested_segments, original_routes = generate_synthetic_routes(G, n_cars=n_cars)
        critical_intersections, signal_directions = identify_critical_intersections(G, congested_segments, original_routes)
        map_before = visualize_before(G, original_routes, congested_segments, critical_intersections, signal_directions)
        display.display(map_before)
        map_before.save("map_before.html")
        print("Before map saved as 'map_before.html'")

    with output_after:
        output_after.clear_output()
        optimized_routes = find_alternative_routes(G, original_routes, congested_segments)
        final_routes = redistribute_cars_with_qaoa(optimized_routes, congested_segments, p=1)
        signal_timings = compute_signal_timings(G, (critical_intersections, signal_directions), original_routes, final_routes)
        map_after = visualize_after_with_signals(G, final_routes, congested_segments, signal_timings)
        display.display(map_after)
        map_after.save("map_after_with_signals.html")
        print("After map saved as 'map_after_with_signals.html'")

    gc.collect()

run_button.on_click(on_run_button_clicked)

# Display UI
display.display(VBox([n_cars_dropdown, run_button, tab]))

print("UI loaded. Select the number of cars and click 'Run Optimization' to see both Before and After results.")

"""Cost Estimation"""

# Install required packages if not already installed
!pip install osmnx folium cirq ipywidgets numpy matplotlib IPython -q

import osmnx as ox
import networkx as nx
from collections import defaultdict
import folium
import cirq
import numpy as np
from scipy.optimize import minimize
import IPython.display as display
from itertools import combinations
import gc
import matplotlib.colors as mcolors
import ipywidgets as widgets
from ipywidgets import Output, VBox, Tab, HTML
import random

# Updated legend with traffic signal entry
legend_html = """
<div style="position: fixed; bottom: 50px; right: 50px; width: 180px; height: 260px;
            background-color: white; border:2px solid grey; z-index:9999; font-size:14px;">
 <b>Traffic Map Legend</b> <br>
 <i class="fa fa-exclamation-triangle fa-1x" style="color:red"></i> Traffic Jam <br>
 <span style="color:purple">Unique Colors</span> Car Routes (Before) <br>
 <i class="fa fa-car fa-1x" style="color:blue"></i> Car Start (Before) <br>
 <i class="fa fa-flag-checkered fa-1x" style="color:red"></i> Car End (Before) <br>
 <i class="fa fa-car fa-1x" style="color:green"></i> Car Start (After) <br>
 <i class="fa fa-flag-checkered fa-1x" style="color:darkgreen"></i> Car End (After) <br>
 <span style="color:green">Green Line</span> Smarter Route (After) <br>
 <i class="fa fa-traffic-light fa-1x" style="color:orange"></i> Traffic Signal <br>
</div>
"""

# Load graph for Times Square
def load_map():
    print("Loading map data for Times Square...")
    G = ox.graph_from_point((40.7558, -73.9864), dist=300, network_type='drive', simplify=False)
    ox.distance.add_edge_lengths(G)
    print(f"Graph loaded with {len(G.nodes)} nodes and {len(G.edges)} edges")
    return G

# Generate synthetic routes with forced congestion
def generate_synthetic_routes(G, n_cars=6):
    print(f"Generating {n_cars} synthetic routes...")
    nodes = list(G.nodes)
    if len(nodes) < 3:
        raise ValueError("Graph too small")
    original_routes = {}
    for car_id in range(n_cars):
        start, mid, end = random.sample(nodes, 3)
        try:
            path1 = nx.shortest_path(G, start, mid, weight='length')
            path2 = nx.shortest_path(G, mid, end, weight='length')
            route = path1[:-1] + path2
            edges = list(zip(route, route[1:]))
            original_routes[car_id] = [edges]
        except nx.NetworkXNoPath:
            print(f"Warning: No path for car {car_id}, using fallback single edge")
            edge = [(start, mid)] if G.has_edge(start, mid) else random.choice(list(G.edges()))
            original_routes[car_id] = [[edge]]
    segment_counts = defaultdict(int)
    for paths in original_routes.values():
        for u, v in paths[0]:
            segment_counts[(u, v)] += 1
    congested_segments = {seg: count for seg, count in segment_counts.items() if count >= 2}
    print(f"Generated routes for {len(original_routes)} cars, Congested segments: {len(congested_segments)}")
    return congested_segments, original_routes

# Identify critical intersections
def identify_critical_intersections(G, congested_segments, original_routes, min_distance=80):
    print("Identifying critical intersections based on congestion...")
    intersection_load = defaultdict(int)
    critical_intersections = {}
    signal_coords = []
    signal_directions = {}
    for (u, v), count in congested_segments.items():
        if G.has_edge(u, v) or G.has_edge(v, u):
            if u in G.nodes and v in G.nodes:
                intersection_load[u] += count
                intersection_load[v] += count
    for paths in original_routes.values():
        for u, v in paths[0]:
            if u in G.nodes and v in G.nodes and G.has_edge(u, v):
                if (u, v) in congested_segments or (v, u) in congested_segments:
                    intersection_load[u] += 1
                    intersection_load[v] += 1
    considered_nodes = set()
    for (u, v), _ in congested_segments.items():
        if G.has_edge(u, v) or G.has_edge(v, u):
            for node in [u, v]:
                if node in G.nodes and node not in considered_nodes:
                    considered_nodes.add(node)
                    lat1, lon1 = G.nodes[node]['y'], G.nodes[node]['x']
                    too_close_node = any(ox.distance.great_circle(lat1, lon1, lat, lon) < min_distance
                                       for lat, lon in signal_coords)
                    too_close_segment = any(G.has_edge(node, existing_node)
                                          for existing_node in critical_intersections)
                    if not (too_close_node or too_close_segment):
                        critical_intersections[node] = intersection_load[node]
                        signal_coords.append((lat1, lon1))
                        signal_directions[node] = determine_directions(G, node)
    for node in G.nodes:
        if node not in considered_nodes:
            lat1, lon1 = G.nodes[node]['y'], G.nodes[node]['x']
            close_to_congestion = any(ox.distance.great_circle(lat1, lon1, G.nodes[u]['y'], G.nodes[u]['x']) < 20
                                    or ox.distance.great_circle(lat1, lon1, G.nodes[v]['y'], G.nodes[v]['x']) < 20
                                    for u, v in congested_segments.keys() if G.has_edge(u, v) or G.has_edge(v, u))
            if close_to_congestion:
                too_close_node = any(ox.distance.great_circle(lat1, lon1, lat, lon) < min_distance
                                   for lat, lon in signal_coords)
                too_close_segment = any(G.has_edge(node, existing_node)
                                      for existing_node in critical_intersections)
                if not (too_close_node or too_close_segment):
                    critical_intersections[node] = intersection_load.get(node, 0)
                    signal_coords.append((lat1, lon1))
                    signal_directions[node] = determine_directions(G, node)
    print(f"Critical intersections: {len(critical_intersections)}")
    return critical_intersections, signal_directions

def determine_directions(G, node):
    directions = []
    if node not in G.nodes:
        return directions
    edges = [(u, v) for u, v in G.edges(node) if u == node or v == node]
    for u, v in edges:
        if u == node:
            lat1, lon1 = G.nodes[u]['y'], G.nodes[u]['x']
            lat2, lon2 = G.nodes[v]['y'], G.nodes[v]['x']
        else:
            lat1, lon1 = G.nodes[v]['y'], G.nodes[v]['x']
            lat2, lon2 = G.nodes[u]['y'], G.nodes[u]['x']
        delta_lon = lon2 - lon1
        delta_lat = lat2 - lat1
        angle = np.degrees(np.arctan2(delta_lon, delta_lat))
        if angle < 0:
            angle += 360
        if 315 <= angle or angle < 45:
            direction = "Northbound"
        elif 45 <= angle < 135:
            direction = "Eastbound"
        elif 135 <= angle < 225:
            direction = "Southbound"
        else:
            direction = "Westbound"
        directions.append(direction)
    return sorted(list(set(directions)))

# Find alternative routes
def find_alternative_routes(G, routes, congested_segments, max_alts=3):
    print("Finding alternative routes...")
    G_simple = nx.Graph(G) if G.is_multigraph() else G
    car_routes = {}
    for car_id, paths in routes.items():
        if not paths or not paths[0]:
            print(f"Warning: Car {car_id} had no initial path, using fallback")
            edge = random.choice(list(G.edges()))
            car_routes[car_id] = [[[edge]]]
            continue
        source, dest = paths[0][0][0], paths[0][-1][1]
        alts = []
        try:
            for path in nx.shortest_simple_paths(G_simple, source, dest, weight='length'):
                if len(alts) >= max_alts: break
                path_edges = list(zip(path, path[1:]))
                if path_edges and path_edges not in alts:
                    alts.append(path_edges)
            if not alts: raise nx.NetworkXNoPath
        except nx.NetworkXNoPath:
            print(f"Warning: No alternative path for car {car_id}, keeping original")
            alts = [paths[0]]
        car_routes[car_id] = alts[:max_alts]
    print(f"Generated alternative routes for {len(car_routes)} cars")
    return car_routes

# Formulate QUBO
def formulate_qubo(routes, congested_segments, penalty=100):
    print("Formulating QUBO...")
    n_cars = len(routes)
    n_alts = 3
    n_vars = n_cars * n_alts
    var_map = {(car_id, alt_id): car_id * n_alts + alt_id for car_id in routes for alt_id in range(n_alts)}
    Q = np.zeros((n_vars, n_vars))
    segment_usage = defaultdict(list)
    for car_id, alts in routes.items():
        for alt_id in range(min(n_alts, len(alts))):
            idx = var_map[(car_id, alt_id)]
            for u, v in alts[alt_id]:
                segment_usage[(u, v)].append(idx)
    for _, indices in segment_usage.items():
        for idx in indices: Q[idx, idx] += 1
        for i, j in combinations(indices, 2):
            Q[i, j] += 2; Q[j, i] += 2
    for car_id in routes:
        indices = [var_map[(car_id, j)] for j in range(min(n_alts, len(routes[car_id])))]
        for idx in indices: Q[idx, idx] -= penalty
        for i, j in combinations(indices, 2):
            Q[i, j] += 2 * penalty; Q[j, i] += 2 * penalty
    return Q, var_map

# Solve QAOA with Cirq
def solve_qaoa_with_cirq(Q, num_vars, p=1):
    print(f"Solving QAOA with {num_vars} variables, p={p}...")
    if num_vars == 0:
        print("No variables to optimize; skipping QAOA.")
        return {}
    qubits = [cirq.LineQubit(i) for i in range(num_vars)]
    simulator = cirq.Simulator()
    best_solution = None
    best_energy = float('inf')
    def evaluate_energy(bitstring):
        return sum(Q[i, j] * bitstring[i] * bitstring[j] for i in range(num_vars) for j in range(num_vars))
    def create_qaoa_circuit(gamma, beta):
        circuit = cirq.Circuit()
        circuit.append(cirq.H.on_each(*qubits))
        for layer in range(p):
            for i in range(num_vars):
                if abs(Q[i, i]) > 1e-6:
                    circuit.append(cirq.rz(2 * gamma[layer] * Q[i, i]).on(qubits[i]))
                for j in range(i + 1, num_vars):
                    if abs(Q[i, j]) > 1e-6:
                        circuit.append(cirq.CNOT(qubits[i], qubits[j]))
                        circuit.append(cirq.rz(2 * gamma[layer] * Q[i, j]).on(qubits[j]))
                        circuit.append(cirq.CNOT(qubits[i], qubits[j]))
            circuit.append(cirq.rx(2 * beta[layer]).on_each(*qubits))
        circuit.append(cirq.measure(*qubits, key='result'))
        return circuit
    def objective(params):
        nonlocal best_solution, best_energy
        gamma = params[:p]
        beta = params[p:]
        circuit = create_qaoa_circuit(gamma, beta)
        result = simulator.run(circuit, repetitions=500)
        measurements = result.measurements['result']
        energy = min(evaluate_energy(bitstring) for bitstring in measurements)
        if energy < best_energy:
            best_energy = energy
            best_solution = tuple(measurements[np.argmin([evaluate_energy(b) for b in measurements])])
        return energy
    initial_params = np.random.uniform(0, np.pi, 2 * p)
    result = minimize(objective, initial_params, method='COBYLA', options={'maxiter': 20})
    return {i: int(bit) for i, bit in enumerate(best_solution)} if best_solution else {i: 0 for i in range(num_vars)}

# Redistribute cars with QAOA
def redistribute_cars_with_qaoa(routes, congested_segments, p=1):
    print("Redistributing cars with QAOA...")
    n_alts = 3
    n_cars = len(routes)
    var_map = {(car_id, alt_id): car_id * n_alts + alt_id for car_id in routes for alt_id in range(n_alts)}
    Q, _ = formulate_qubo(routes, congested_segments)
    final_routes = {}
    group_size = 6
    groups = [range(i, min(i + group_size, n_cars)) for i in range(0, n_cars, group_size)]
    for group in groups:
        subset_routes = {car_id: routes[car_id] for car_id in group if car_id in routes}
        if not subset_routes:
            continue
        subset_var_map = {(car_id, alt_id): var_map[(car_id, alt_id)] for car_id in subset_routes for alt_id in range(n_alts)}
        subset_vars = list(subset_var_map.values())
        Q_subset = Q[np.ix_(subset_vars, subset_vars)]
        solution = solve_qaoa_with_cirq(Q_subset, len(subset_var_map), p)
        for car_id in subset_routes:
            assigned = False
            for alt_id in range(min(n_alts, len(routes[car_id]))):
                if solution.get(subset_var_map[(car_id, alt_id)], 0) == 1:
                    final_routes[car_id] = [routes[car_id][alt_id]]
                    assigned = True
                    break
            if not assigned and routes[car_id]:
                final_routes[car_id] = [routes[car_id][0]]
    for car_id in routes:
        if car_id not in final_routes:
            print(f"Warning: Car {car_id} not assigned by QAOA, using original route")
            final_routes[car_id] = [routes[car_id][0]]
    print(f"Optimized routes for {len(final_routes)} cars")
    return final_routes

# Compute signal timings
def compute_signal_timings(G, critical_data, routes_before, routes_after=None):
    print("Computing signal timings with directions...")
    signal_timings = {}
    max_cycle = 120
    critical_intersections, signal_directions = critical_data
    for node in critical_intersections:
        routes_to_use = routes_after if routes_after else routes_before
        before_count = sum(1 for paths in routes_before.values() for u, v in paths[0] if u == node or v == node)
        after_count = sum(1 for paths in routes_to_use.values() for u, v in paths[0] if u == node or v == node)
        green = min(60, max(20, after_count * 2)) if after_count > 0 else max(20, before_count * 1.5)
        red = max_cycle - green - 5
        signal_timings[node] = {
            'green': green,
            'yellow': 5,
            'red': red,
            'coords': (G.nodes[node]['y'], G.nodes[node]['x']),
            'directions': signal_directions.get(node, [])
        }
        print(f"Traffic Signal @ Node {node}: Green={green}s, Red={red}s, Directions={', '.join(signal_directions.get(node, []))}")
    return signal_timings

# Calculate route cost (distance in meters)
def calculate_route_cost(G, route):
    total_cost = 0
    for u, v in route[0]:  # route is a list of edge lists
        if G.has_edge(u, v):
            edge_data = G.get_edge_data(u, v, 0)  # 0 for first edge in multi-graph
            total_cost += edge_data.get('length', 0)
        else:
            print(f"Warning: Edge ({u}, {v}) not in graph, cost not added")
    return total_cost

# Visualize before optimization with cost
def visualize_before(G, original_routes, congested_segments, critical_intersections, signal_directions):
    print("Visualizing before optimization...")
    m = folium.Map(location=(40.7558, -73.9864), zoom_start=15)
    color_list = list(mcolors.TABLEAU_COLORS.values()) + list(mcolors.CSS4_COLORS.values())[:24]
    unique_colors = color_list[:len(original_routes)]
    for (u, v), count in congested_segments.items():
        if u in G.nodes and v in G.nodes and G.has_edge(u, v):
            coords = [(G.nodes[u]['y'], G.nodes[u]['x']), (G.nodes[v]['y'], G.nodes[v]['x'])]
            folium.PolyLine(coords, color='red', weight=8, opacity=0.8, tooltip=f'Jam: {count} cars').add_to(m)
            folium.Marker(coords[0], icon=folium.Icon(color='red', icon='exclamation-triangle', prefix='fa')).add_to(m)
    visualized_cars = 0
    car_costs = {}
    total_cost = 0
    for car_id in range(len(original_routes)):
        path = original_routes.get(car_id, [[]])
        cost = calculate_route_cost(G, path)
        car_costs[car_id] = cost
        total_cost += cost
        if path and path[0]:
            points = [(G.nodes[u]['y'], G.nodes[u]['x']) for u, v in path[0] if u in G.nodes and v in G.nodes and G.has_edge(u, v)]
            if not points:
                u, v = path[0][0] if path[0] else (list(G.nodes)[0], list(G.nodes)[1])
                points = [(G.nodes[u]['y'], G.nodes[u]['x'])]
                print(f"Warning: Car {car_id} has no valid edges in Before map, using start point")
            unique_points = list(dict.fromkeys(points))
            car_color = unique_colors[car_id % len(unique_colors)]
            print(f"Car {car_id} Before: Plotting {len(unique_points)} points, Cost: {cost:.2f} meters")
            folium.PolyLine(unique_points, color=car_color, weight=4, tooltip=f'Car {car_id} (Cost: {cost:.2f}m)').add_to(m)
            folium.Marker(unique_points[0], icon=folium.Icon(color='blue', icon='car', prefix='fa'),
                         tooltip=f'Car {car_id} Start (Cost: {cost:.2f}m)').add_to(m)
            end_point = unique_points[-1] if len(unique_points) > 1 else unique_points[0]
            folium.Marker(end_point, icon=folium.Icon(color='red', icon='flag-checkered', prefix='fa'),
                         tooltip=f'Car {car_id} End (Cost: {cost:.2f}m)').add_to(m)
            visualized_cars += 1
        else:
            print(f"Warning: Car {car_id} has no route in Before map, plotting at default location, Cost: {cost:.2f} meters")
            default_point = (G.nodes[list(G.nodes)[0]]['y'], G.nodes[list(G.nodes)[0]]['x'])
            folium.Marker(default_point, icon=folium.Icon(color='blue', icon='car', prefix='fa'),
                         tooltip=f'Car {car_id} Start (No Route, Cost: {cost:.2f}m)').add_to(m)
            folium.Marker(default_point, icon=folium.Icon(color='red', icon='flag-checkered', prefix='fa'),
                         tooltip=f'Car {car_id} End (No Route, Cost: {cost:.2f}m)').add_to(m)
            visualized_cars += 1
    signal_timings = compute_signal_timings(G, (critical_intersections, signal_directions), original_routes)
    for node, timings in signal_timings.items():
        directions_str = ", ".join(timings['directions']) if timings['directions'] else "All directions"
        folium.Marker(
            timings['coords'],
            icon=folium.Icon(color='orange', icon='traffic-light', prefix='fa', icon_size=(30, 30)),
            tooltip=f"Traffic Signal @ Node {node}: Green={timings['green']}s, Red={timings['red']}s, Directions={directions_str}"
        ).add_to(m)
        folium.Circle(timings['coords'], radius=20, color='orange', fill=True, fill_opacity=0.4).add_to(m)
    m.get_root().html.add_child(folium.Element(legend_html))
    print(f"Visualized {visualized_cars} cars in Before map")
    cost_summary = "<h3>Before Optimization Costs</h3><ul>" + "".join(f"<li>Car {car_id}: {cost:.2f} meters</li>" for car_id, cost in car_costs.items()) + f"</ul><p><strong>Total Cost: {total_cost:.2f} meters</strong></p>"
    return m, car_costs, total_cost, cost_summary

# Visualize after optimization with cost
def visualize_after_with_signals(G, optimized_routes, congested_segments, signal_timings):
    print("Visualizing after optimization with enhanced traffic signals...")
    m = folium.Map(location=(40.7558, -73.9864), zoom_start=15)
    for (u, v), count in congested_segments.items():
        if u in G.nodes and v in G.nodes:
            coords = [(G.nodes[u]['y'], G.nodes[u]['x']), (G.nodes[v]['y'], G.nodes[v]['x'])]
            folium.PolyLine(coords, color='red', weight=8, opacity=0.5, tooltip=f'Jam: {count} cars').add_to(m)
            folium.Marker(coords[0], icon=folium.Icon(color='red', icon='exclamation-triangle', prefix='fa')).add_to(m)
    visualized_cars = 0
    car_costs = {}
    total_cost = 0
    for car_id in range(len(optimized_routes)):
        paths = optimized_routes.get(car_id, [[]])
        cost = calculate_route_cost(G, paths)
        car_costs[car_id] = cost
        total_cost += cost
        if paths and paths[0]:
            points = []
            for u, v in paths[0]:
                if u in G.nodes and v in G.nodes:
                    points.append((G.nodes[u]['y'], G.nodes[u]['x']))
                else:
                    print(f"Warning: Invalid node pair ({u}, {v}) for car {car_id} in After map")
            if not points:
                u, v = paths[0][0] if paths[0] else (list(G.nodes)[0], list(G.nodes)[1])
                points = [(G.nodes[u]['y'], G.nodes[u]['x'])]
                print(f"Warning: Car {car_id} has no valid edges in After map, using start point")
            unique_points = list(dict.fromkeys(points))
            print(f"Car {car_id} After: Plotting {len(unique_points)} points, Cost: {cost:.2f} meters")
            folium.PolyLine(unique_points, color='green', weight=4, dash_array='5', tooltip=f'Car {car_id} (Cost: {cost:.2f}m)').add_to(m)
            folium.Marker(unique_points[0], icon=folium.Icon(color='green', icon='car', prefix='fa'),
                         tooltip=f'Car {car_id} Start (Cost: {cost:.2f}m)').add_to(m)
            end_point = unique_points[-1] if len(unique_points) > 1 else unique_points[0]
            folium.Marker(end_point, icon=folium.Icon(color='darkgreen', icon='flag-checkered', prefix='fa'),
                         tooltip=f'Car {car_id} End (Cost: {cost:.2f}m)').add_to(m)
            visualized_cars += 1
        else:
            print(f"Warning: Car {car_id} has no route in After map, plotting at default location, Cost: {cost:.2f} meters")
            default_point = (G.nodes[list(G.nodes)[0]]['y'], G.nodes[list(G.nodes)[0]]['x'])
            folium.Marker(default_point, icon=folium.Icon(color='green', icon='car', prefix='fa'),
                         tooltip=f'Car {car_id} Start (No Route, Cost: {cost:.2f}m)').add_to(m)
            folium.Marker(default_point, icon=folium.Icon(color='darkgreen', icon='flag-checkered', prefix='fa'),
                         tooltip=f'Car {car_id} End (No Route, Cost: {cost:.2f}m)').add_to(m)
            visualized_cars += 1
    for node, timings in signal_timings.items():
        directions_str = ", ".join(timings['directions']) if timings['directions'] else "All directions"
        folium.Marker(
            timings['coords'],
            icon=folium.Icon(color='orange', icon='traffic-light', prefix='fa', icon_size=(30, 30)),
            tooltip=f"Traffic Signal @ Node {node}: Green={timings['green']}s, Red={timings['red']}s, Directions={directions_str}"
        ).add_to(m)
        folium.Circle(timings['coords'], radius=20, color='orange', fill=True, fill_opacity=0.4).add_to(m)
    m.get_root().html.add_child(folium.Element(legend_html))
    print(f"Visualized {visualized_cars} cars in After map")
    cost_summary = "<h3>After Optimization Costs</h3><ul>" + "".join(f"<li>Car {car_id}: {cost:.2f} meters</li>" for car_id, cost in car_costs.items()) + f"</ul><p><strong>Total Cost: {total_cost:.2f} meters</strong></p>"
    return m, car_costs, total_cost, cost_summary

# UI and Main Logic
G = load_map()  # Load map once

# Widgets
n_cars_dropdown = widgets.Dropdown(options=[6, 12, 18, 24], value=6, description='Number of Cars:')
run_button = widgets.Button(description="Run Optimization")
output_before = Output()
output_after = Output()

# Tab layout for outputs
tab = Tab(children=[output_before, output_after])
tab.set_title(0, 'Before Optimization')
tab.set_title(1, 'After Optimization')

# Event handler for Run Optimization
def on_run_button_clicked(b):
    n_cars = n_cars_dropdown.value
    with output_before:
        output_before.clear_output()
        congested_segments, original_routes = generate_synthetic_routes(G, n_cars=n_cars)
        critical_intersections, signal_directions = identify_critical_intersections(G, congested_segments, original_routes)
        map_before, before_costs, total_before_cost, cost_summary_before = visualize_before(G, original_routes, congested_segments, critical_intersections, signal_directions)
        display.display(map_before)
        display.display(HTML(cost_summary_before))
        map_before.save("map_before.html")
        print("Before map saved as 'map_before.html'")

    with output_after:
        output_after.clear_output()
        optimized_routes = find_alternative_routes(G, original_routes, congested_segments)
        final_routes = redistribute_cars_with_qaoa(optimized_routes, congested_segments, p=1)
        signal_timings = compute_signal_timings(G, (critical_intersections, signal_directions), original_routes, final_routes)
        map_after, after_costs, total_after_cost, cost_summary_after = visualize_after_with_signals(G, final_routes, congested_segments, signal_timings)
        display.display(map_after)
        display.display(HTML(cost_summary_after))
        map_after.save("map_after_with_signals.html")
        print("After map saved as 'map_after_with_signals.html'")

    gc.collect()

run_button.on_click(on_run_button_clicked)

# Display UI
display.display(VBox([n_cars_dropdown, run_button, tab]))

print("UI loaded. Select the number of cars and click 'Run Optimization' to see both Before and After results with costs.")

# Install required packages if not already installed
!pip install osmnx folium cirq ipywidgets numpy matplotlib IPython -q

import osmnx as ox
import networkx as nx
from collections import defaultdict
import folium
import cirq
import numpy as np
from scipy.optimize import minimize
import IPython.display as display
from itertools import combinations
import gc
import matplotlib.colors as mcolors
import ipywidgets as widgets
from ipywidgets import Output, VBox, Tab, HTML
import random

# Updated legend with traffic signal entry
legend_html = """
<div style="position: fixed; bottom: 50px; right: 50px; width: 180px; height: 260px;
            background-color: white; border:2px solid grey; z-index:9999; font-size:14px;">
 <b>Traffic Map Legend</b> <br>
 <i class="fa fa-exclamation-triangle fa-1x" style="color:red"></i> Traffic Jam <br>
 <span style="color:purple">Unique Colors</span> Car Routes (Before) <br>
 <i class="fa fa-car fa-1x" style="color:blue"></i> Car Start (Before) <br>
 <i class="fa fa-flag-checkered fa-1x" style="color:red"></i> Car End (Before) <br>
 <i class="fa fa-car fa-1x" style="color:green"></i> Car Start (After) <br>
 <i class="fa fa-flag-checkered fa-1x" style="color:darkgreen"></i> Car End (After) <br>
 <span style="color:green">Green Line</span> Smarter Route (After) <br>
 <i class="fa fa-traffic-light fa-1x" style="color:orange"></i> Traffic Signal <br>
</div>
"""

# Load graph for Times Square
def load_map():
    print("Loading map data for Times Square...")
    G = ox.graph_from_point((40.7558, -73.9864), dist=300, network_type='drive', simplify=False)
    ox.distance.add_edge_lengths(G)
    print(f"Graph loaded with {len(G.nodes)} nodes and {len(G.edges)} edges")
    return G

# Generate synthetic routes with forced congestion
def generate_synthetic_routes(G, n_cars=6):
    print(f"Generating {n_cars} synthetic routes...")
    nodes = list(G.nodes)
    if len(nodes) < 3:
        raise ValueError("Graph too small")
    original_routes = {}
    for car_id in range(n_cars):
        start, mid, end = random.sample(nodes, 3)
        try:
            path1 = nx.shortest_path(G, start, mid, weight='length')
            path2 = nx.shortest_path(G, mid, end, weight='length')
            route = path1[:-1] + path2
            edges = list(zip(route, route[1:]))
            original_routes[car_id] = [edges]
        except nx.NetworkXNoPath:
            print(f"Warning: No path for car {car_id}, using fallback single edge")
            edge = [(start, mid)] if G.has_edge(start, mid) else random.choice(list(G.edges()))
            original_routes[car_id] = [[edge]]
    segment_counts = defaultdict(int)
    for paths in original_routes.values():
        for u, v in paths[0]:
            segment_counts[(u, v)] += 1
    congested_segments = {seg: count for seg, count in segment_counts.items() if count >= 2}
    print(f"Generated routes for {len(original_routes)} cars, Congested segments: {len(congested_segments)}")
    return congested_segments, original_routes

# Identify critical intersections
def identify_critical_intersections(G, congested_segments, original_routes, min_distance=80):
    print("Identifying critical intersections based on congestion...")
    intersection_load = defaultdict(int)
    critical_intersections = {}
    signal_coords = []
    signal_directions = {}
    for (u, v), count in congested_segments.items():
        if G.has_edge(u, v) or G.has_edge(v, u):
            if u in G.nodes and v in G.nodes:
                intersection_load[u] += count
                intersection_load[v] += count
    for paths in original_routes.values():
        for u, v in paths[0]:
            if u in G.nodes and v in G.nodes and G.has_edge(u, v):
                if (u, v) in congested_segments or (v, u) in congested_segments:
                    intersection_load[u] += 1
                    intersection_load[v] += 1
    considered_nodes = set()
    for (u, v), _ in congested_segments.items():
        if G.has_edge(u, v) or G.has_edge(v, u):
            for node in [u, v]:
                if node in G.nodes and node not in considered_nodes:
                    considered_nodes.add(node)
                    lat1, lon1 = G.nodes[node]['y'], G.nodes[node]['x']
                    too_close_node = any(ox.distance.great_circle(lat1, lon1, lat, lon) < min_distance
                                       for lat, lon in signal_coords)
                    too_close_segment = any(G.has_edge(node, existing_node)
                                          for existing_node in critical_intersections)
                    if not (too_close_node or too_close_segment):
                        critical_intersections[node] = intersection_load[node]
                        signal_coords.append((lat1, lon1))
                        signal_directions[node] = determine_directions(G, node)
    for node in G.nodes:
        if node not in considered_nodes:
            lat1, lon1 = G.nodes[node]['y'], G.nodes[node]['x']
            close_to_congestion = any(ox.distance.great_circle(lat1, lon1, G.nodes[u]['y'], G.nodes[u]['x']) < 20
                                    or ox.distance.great_circle(lat1, lon1, G.nodes[v]['y'], G.nodes[v]['x']) < 20
                                    for u, v in congested_segments.keys() if G.has_edge(u, v) or G.has_edge(v, u))
            if close_to_congestion:
                too_close_node = any(ox.distance.great_circle(lat1, lon1, lat, lon) < min_distance
                                   for lat, lon in signal_coords)
                too_close_segment = any(G.has_edge(node, existing_node)
                                      for existing_node in critical_intersections)
                if not (too_close_node or too_close_segment):
                    critical_intersections[node] = intersection_load.get(node, 0)
                    signal_coords.append((lat1, lon1))
                    signal_directions[node] = determine_directions(G, node)
    print(f"Critical intersections: {len(critical_intersections)}")
    return critical_intersections, signal_directions

def determine_directions(G, node):
    directions = []
    if node not in G.nodes:
        return directions
    edges = [(u, v) for u, v in G.edges(node) if u == node or v == node]
    for u, v in edges:
        if u == node:
            lat1, lon1 = G.nodes[u]['y'], G.nodes[u]['x']
            lat2, lon2 = G.nodes[v]['y'], G.nodes[v]['x']
        else:
            lat1, lon1 = G.nodes[v]['y'], G.nodes[v]['x']
            lat2, lon2 = G.nodes[u]['y'], G.nodes[u]['x']
        delta_lon = lon2 - lon1
        delta_lat = lat2 - lat1
        angle = np.degrees(np.arctan2(delta_lon, delta_lat))
        if angle < 0:
            angle += 360
        if 315 <= angle or angle < 45:
            direction = "Northbound"
        elif 45 <= angle < 135:
            direction = "Eastbound"
        elif 135 <= angle < 225:
            direction = "Southbound"
        else:
            direction = "Westbound"
        directions.append(direction)
    return sorted(list(set(directions)))

# Find alternative routes
def find_alternative_routes(G, routes, congested_segments, max_alts=3):
    print("Finding alternative routes...")
    G_simple = nx.Graph(G) if G.is_multigraph() else G
    car_routes = {}
    for car_id, paths in routes.items():
        if not paths or not paths[0]:
            print(f"Warning: Car {car_id} had no initial path, using fallback")
            edge = random.choice(list(G.edges()))
            car_routes[car_id] = [[[edge]]]
            continue
        source, dest = paths[0][0][0], paths[0][-1][1]
        alts = []
        try:
            for path in nx.shortest_simple_paths(G_simple, source, dest, weight='length'):
                if len(alts) >= max_alts: break
                path_edges = list(zip(path, path[1:]))
                if path_edges and path_edges not in alts:
                    alts.append(path_edges)
            if not alts: raise nx.NetworkXNoPath
        except nx.NetworkXNoPath:
            print(f"Warning: No alternative path for car {car_id}, keeping original")
            alts = [paths[0]]
        car_routes[car_id] = alts[:max_alts]
    print(f"Generated alternative routes for {len(car_routes)} cars")
    return car_routes

# Formulate QUBO
def formulate_qubo(routes, congested_segments, penalty=100):
    print("Formulating QUBO...")
    n_cars = len(routes)
    n_alts = 3
    n_vars = n_cars * n_alts
    var_map = {(car_id, alt_id): car_id * n_alts + alt_id for car_id in routes for alt_id in range(n_alts)}
    Q = np.zeros((n_vars, n_vars))
    segment_usage = defaultdict(list)
    for car_id, alts in routes.items():
        for alt_id in range(min(n_alts, len(alts))):
            idx = var_map[(car_id, alt_id)]
            for u, v in alts[alt_id]:
                segment_usage[(u, v)].append(idx)
    for _, indices in segment_usage.items():
        for idx in indices: Q[idx, idx] += 1
        for i, j in combinations(indices, 2):
            Q[i, j] += 2; Q[j, i] += 2
    for car_id in routes:
        indices = [var_map[(car_id, j)] for j in range(min(n_alts, len(routes[car_id])))]
        for idx in indices: Q[idx, idx] -= penalty
        for i, j in combinations(indices, 2):
            Q[i, j] += 2 * penalty; Q[j, i] += 2 * penalty
    return Q, var_map

# Solve QAOA with Cirq
def solve_qaoa_with_cirq(Q, num_vars, p=1):
    print(f"Solving QAOA with {num_vars} variables, p={p}...")
    if num_vars == 0:
        print("No variables to optimize; skipping QAOA.")
        return {}
    qubits = [cirq.LineQubit(i) for i in range(num_vars)]
    simulator = cirq.Simulator()
    best_solution = None
    best_energy = float('inf')
    def evaluate_energy(bitstring):
        return sum(Q[i, j] * bitstring[i] * bitstring[j] for i in range(num_vars) for j in range(num_vars))
    def create_qaoa_circuit(gamma, beta):
        circuit = cirq.Circuit()
        circuit.append(cirq.H.on_each(*qubits))
        for layer in range(p):
            for i in range(num_vars):
                if abs(Q[i, i]) > 1e-6:
                    circuit.append(cirq.rz(2 * gamma[layer] * Q[i, i]).on(qubits[i]))
                for j in range(i + 1, num_vars):
                    if abs(Q[i, j]) > 1e-6:
                        circuit.append(cirq.CNOT(qubits[i], qubits[j]))
                        circuit.append(cirq.rz(2 * gamma[layer] * Q[i, j]).on(qubits[j]))
                        circuit.append(cirq.CNOT(qubits[i], qubits[j]))
            circuit.append(cirq.rx(2 * beta[layer]).on_each(*qubits))
        circuit.append(cirq.measure(*qubits, key='result'))
        return circuit
    def objective(params):
        nonlocal best_solution, best_energy
        gamma = params[:p]
        beta = params[p:]
        circuit = create_qaoa_circuit(gamma, beta)
        result = simulator.run(circuit, repetitions=500)
        measurements = result.measurements['result']
        energy = min(evaluate_energy(bitstring) for bitstring in measurements)
        if energy < best_energy:
            best_energy = energy
            best_solution = tuple(measurements[np.argmin([evaluate_energy(b) for b in measurements])])
        return energy
    initial_params = np.random.uniform(0, np.pi, 2 * p)
    result = minimize(objective, initial_params, method='COBYLA', options={'maxiter': 20})
    return {i: int(bit) for i, bit in enumerate(best_solution)} if best_solution else {i: 0 for i in range(num_vars)}

# Redistribute cars with QAOA
def redistribute_cars_with_qaoa(routes, congested_segments, p=1):
    print("Redistributing cars with QAOA...")
    n_alts = 3
    n_cars = len(routes)
    var_map = {(car_id, alt_id): car_id * n_alts + alt_id for car_id in routes for alt_id in range(n_alts)}
    Q, _ = formulate_qubo(routes, congested_segments)
    final_routes = {}
    group_size = 6
    groups = [range(i, min(i + group_size, n_cars)) for i in range(0, n_cars, group_size)]
    for group in groups:
        subset_routes = {car_id: routes[car_id] for car_id in group if car_id in routes}
        if not subset_routes:
            continue
        subset_var_map = {(car_id, alt_id): var_map[(car_id, alt_id)] for car_id in subset_routes for alt_id in range(n_alts)}
        subset_vars = list(subset_var_map.values())
        Q_subset = Q[np.ix_(subset_vars, subset_vars)]
        solution = solve_qaoa_with_cirq(Q_subset, len(subset_var_map), p)
        for car_id in subset_routes:
            assigned = False
            for alt_id in range(min(n_alts, len(routes[car_id]))):
                if solution.get(subset_var_map[(car_id, alt_id)], 0) == 1:
                    final_routes[car_id] = [routes[car_id][alt_id]]
                    assigned = True
                    break
            if not assigned and routes[car_id]:
                final_routes[car_id] = [routes[car_id][0]]
    for car_id in routes:
        if car_id not in final_routes:
            print(f"Warning: Car {car_id} not assigned by QAOA, using original route")
            final_routes[car_id] = [routes[car_id][0]]
    print(f"Optimized routes for {len(final_routes)} cars")
    return final_routes

# Compute signal timings
def compute_signal_timings(G, critical_data, routes_before, routes_after=None):
    print("Computing signal timings with directions...")
    signal_timings = {}
    max_cycle = 120
    critical_intersections, signal_directions = critical_data
    for node in critical_intersections:
        routes_to_use = routes_after if routes_after else routes_before
        before_count = sum(1 for paths in routes_before.values() for u, v in paths[0] if u == node or v == node)
        after_count = sum(1 for paths in routes_to_use.values() for u, v in paths[0] if u == node or v == node)
        green = min(60, max(20, after_count * 2)) if after_count > 0 else max(20, before_count * 1.5)
        red = max_cycle - green - 5
        signal_timings[node] = {
            'green': green,
            'yellow': 5,
            'red': red,
            'coords': (G.nodes[node]['y'], G.nodes[node]['x']),
            'directions': signal_directions.get(node, [])
        }
        print(f"Traffic Signal @ Node {node}: Green={green}s, Red={red}s, Directions={', '.join(signal_directions.get(node, []))}")
    return signal_timings

# Calculate route cost in rupees (assuming ₹0.05 per meter)
def calculate_route_cost(G, route):
    total_distance = 0
    for u, v in route[0]:  # route is a list of edge lists
        if G.has_edge(u, v):
            edge_data = G.get_edge_data(u, v, 0)  # 0 for first edge in multi-graph
            total_distance += edge_data.get('length', 0)
        else:
            print(f"Warning: Edge ({u}, {v}) not in graph, cost not added")
    cost_in_rupees = total_distance * 0.05  # ₹0.05 per meter
    return cost_in_rupees

# Visualize before optimization with cost in rupees
def visualize_before(G, original_routes, congested_segments, critical_intersections, signal_directions):
    print("Visualizing before optimization...")
    m = folium.Map(location=(40.7558, -73.9864), zoom_start=15)
    color_list = list(mcolors.TABLEAU_COLORS.values()) + list(mcolors.CSS4_COLORS.values())[:24]
    unique_colors = color_list[:len(original_routes)]
    for (u, v), count in congested_segments.items():
        if u in G.nodes and v in G.nodes and G.has_edge(u, v):
            coords = [(G.nodes[u]['y'], G.nodes[u]['x']), (G.nodes[v]['y'], G.nodes[v]['x'])]
            folium.PolyLine(coords, color='red', weight=8, opacity=0.8, tooltip=f'Jam: {count} cars').add_to(m)
            folium.Marker(coords[0], icon=folium.Icon(color='red', icon='exclamation-triangle', prefix='fa')).add_to(m)
    visualized_cars = 0
    car_costs = {}
    total_cost = 0
    for car_id in range(len(original_routes)):
        path = original_routes.get(car_id, [[]])
        cost = calculate_route_cost(G, path)
        car_costs[car_id] = cost
        total_cost += cost
        if path and path[0]:
            points = [(G.nodes[u]['y'], G.nodes[u]['x']) for u, v in path[0] if u in G.nodes and v in G.nodes and G.has_edge(u, v)]
            if not points:
                u, v = path[0][0] if path[0] else (list(G.nodes)[0], list(G.nodes)[1])
                points = [(G.nodes[u]['y'], G.nodes[u]['x'])]
                print(f"Warning: Car {car_id} has no valid edges in Before map, using start point")
            unique_points = list(dict.fromkeys(points))
            car_color = unique_colors[car_id % len(unique_colors)]
            print(f"Car {car_id} Before: Plotting {len(unique_points)} points, Cost: ₹{cost:.2f}")
            folium.PolyLine(unique_points, color=car_color, weight=4, tooltip=f'Car {car_id} (Cost: ₹{cost:.2f})').add_to(m)
            folium.Marker(unique_points[0], icon=folium.Icon(color='blue', icon='car', prefix='fa'),
                         tooltip=f'Car {car_id} Start (Cost: ₹{cost:.2f})').add_to(m)
            end_point = unique_points[-1] if len(unique_points) > 1 else unique_points[0]
            folium.Marker(end_point, icon=folium.Icon(color='red', icon='flag-checkered', prefix='fa'),
                         tooltip=f'Car {car_id} End (Cost: ₹{cost:.2f})').add_to(m)
            visualized_cars += 1
        else:
            print(f"Warning: Car {car_id} has no route in Before map, plotting at default location, Cost: ₹{cost:.2f}")
            default_point = (G.nodes[list(G.nodes)[0]]['y'], G.nodes[list(G.nodes)[0]]['x'])
            folium.Marker(default_point, icon=folium.Icon(color='blue', icon='car', prefix='fa'),
                         tooltip=f'Car {car_id} Start (No Route, Cost: ₹{cost:.2f})').add_to(m)
            folium.Marker(default_point, icon=folium.Icon(color='red', icon='flag-checkered', prefix='fa'),
                         tooltip=f'Car {car_id} End (No Route, Cost: ₹{cost:.2f})').add_to(m)
            visualized_cars += 1
    signal_timings = compute_signal_timings(G, (critical_intersections, signal_directions), original_routes)
    for node, timings in signal_timings.items():
        directions_str = ", ".join(timings['directions']) if timings['directions'] else "All directions"
        folium.Marker(
            timings['coords'],
            icon=folium.Icon(color='orange', icon='traffic-light', prefix='fa', icon_size=(30, 30)),
            tooltip=f"Traffic Signal @ Node {node}: Green={timings['green']}s, Red={timings['red']}s, Directions={directions_str}"
        ).add_to(m)
        folium.Circle(timings['coords'], radius=20, color='orange', fill=True, fill_opacity=0.4).add_to(m)
    m.get_root().html.add_child(folium.Element(legend_html))
    print(f"Visualized {visualized_cars} cars in Before map")
    cost_summary = "<h3>Before Optimization Costs</h3><ul>" + "".join(f"<li>Car {car_id}: ₹{cost:.2f}</li>" for car_id, cost in car_costs.items()) + f"</ul><p><strong>Total Cost: ₹{total_cost:.2f}</strong></p>"
    return m, car_costs, total_cost, cost_summary

# Visualize after optimization with cost in rupees
def visualize_after_with_signals(G, optimized_routes, congested_segments, signal_timings):
    print("Visualizing after optimization with enhanced traffic signals...")
    m = folium.Map(location=(40.7558, -73.9864), zoom_start=15)
    for (u, v), count in congested_segments.items():
        if u in G.nodes and v in G.nodes:
            coords = [(G.nodes[u]['y'], G.nodes[u]['x']), (G.nodes[v]['y'], G.nodes[v]['x'])]
            folium.PolyLine(coords, color='red', weight=8, opacity=0.5, tooltip=f'Jam: {count} cars').add_to(m)
            folium.Marker(coords[0], icon=folium.Icon(color='red', icon='exclamation-triangle', prefix='fa')).add_to(m)
    visualized_cars = 0
    car_costs = {}
    total_cost = 0
    for car_id in range(len(optimized_routes)):
        paths = optimized_routes.get(car_id, [[]])
        cost = calculate_route_cost(G, paths)
        car_costs[car_id] = cost
        total_cost += cost
        if paths and paths[0]:
            points = []
            for u, v in paths[0]:
                if u in G.nodes and v in G.nodes:
                    points.append((G.nodes[u]['y'], G.nodes[u]['x']))
                else:
                    print(f"Warning: Invalid node pair ({u}, {v}) for car {car_id} in After map")
            if not points:
                u, v = paths[0][0] if paths[0] else (list(G.nodes)[0], list(G.nodes)[1])
                points = [(G.nodes[u]['y'], G.nodes[u]['x'])]
                print(f"Warning: Car {car_id} has no valid edges in After map, using start point")
            unique_points = list(dict.fromkeys(points))
            print(f"Car {car_id} After: Plotting {len(unique_points)} points, Cost: ₹{cost:.2f}")
            folium.PolyLine(unique_points, color='green', weight=4, dash_array='5', tooltip=f'Car {car_id} (Cost: ₹{cost:.2f})').add_to(m)
            folium.Marker(unique_points[0], icon=folium.Icon(color='green', icon='car', prefix='fa'),
                         tooltip=f'Car {car_id} Start (Cost: ₹{cost:.2f})').add_to(m)
            end_point = unique_points[-1] if len(unique_points) > 1 else unique_points[0]
            folium.Marker(end_point, icon=folium.Icon(color='darkgreen', icon='flag-checkered', prefix='fa'),
                         tooltip=f'Car {car_id} End (Cost: ₹{cost:.2f})').add_to(m)
            visualized_cars += 1
        else:
            print(f"Warning: Car {car_id} has no route in After map, plotting at default location, Cost: ₹{cost:.2f}")
            default_point = (G.nodes[list(G.nodes)[0]]['y'], G.nodes[list(G.nodes)[0]]['x'])
            folium.Marker(default_point, icon=folium.Icon(color='green', icon='car', prefix='fa'),
                         tooltip=f'Car {car_id} Start (No Route, Cost: ₹{cost:.2f})').add_to(m)
            folium.Marker(default_point, icon=folium.Icon(color='darkgreen', icon='flag-checkered', prefix='fa'),
                         tooltip=f'Car {car_id} End (No Route, Cost: ₹{cost:.2f})').add_to(m)
            visualized_cars += 1
    for node, timings in signal_timings.items():
        directions_str = ", ".join(timings['directions']) if timings['directions'] else "All directions"
        folium.Marker(
            timings['coords'],
            icon=folium.Icon(color='orange', icon='traffic-light', prefix='fa', icon_size=(30, 30)),
            tooltip=f"Traffic Signal @ Node {node}: Green={timings['green']}s, Red={timings['red']}s, Directions={directions_str}"
        ).add_to(m)
        folium.Circle(timings['coords'], radius=20, color='orange', fill=True, fill_opacity=0.4).add_to(m)
    m.get_root().html.add_child(folium.Element(legend_html))
    print(f"Visualized {visualized_cars} cars in After map")
    cost_summary = "<h3>After Optimization Costs</h3><ul>" + "".join(f"<li>Car {car_id}: ₹{cost:.2f}</li>" for car_id, cost in car_costs.items()) + f"</ul><p><strong>Total Cost: ₹{total_cost:.2f}</strong></p>"
    return m, car_costs, total_cost, cost_summary

# UI and Main Logic
G = load_map()  # Load map once

# Widgets
n_cars_dropdown = widgets.Dropdown(options=[6, 12, 18, 24], value=6, description='Number of Cars:')
run_button = widgets.Button(description="Run Optimization")
output_before = Output()
output_after = Output()

# Tab layout for outputs
tab = Tab(children=[output_before, output_after])
tab.set_title(0, 'Before Optimization')
tab.set_title(1, 'After Optimization')

# Event handler for Run Optimization
def on_run_button_clicked(b):
    n_cars = n_cars_dropdown.value
    with output_before:
        output_before.clear_output()
        congested_segments, original_routes = generate_synthetic_routes(G, n_cars=n_cars)
        critical_intersections, signal_directions = identify_critical_intersections(G, congested_segments, original_routes)
        map_before, before_costs, total_before_cost, cost_summary_before = visualize_before(G, original_routes, congested_segments, critical_intersections, signal_directions)
        display.display(map_before)
        display.display(HTML(cost_summary_before))
        map_before.save("map_before.html")
        print("Before map saved as 'map_before.html'")

    with output_after:
        output_after.clear_output()
        optimized_routes = find_alternative_routes(G, original_routes, congested_segments)
        final_routes = redistribute_cars_with_qaoa(optimized_routes, congested_segments, p=1)
        signal_timings = compute_signal_timings(G, (critical_intersections, signal_directions), original_routes, final_routes)
        map_after, after_costs, total_after_cost, cost_summary_after = visualize_after_with_signals(G, final_routes, congested_segments, signal_timings)
        display.display(map_after)
        display.display(HTML(cost_summary_after))
        map_after.save("map_after_with_signals.html")
        print("After map saved as 'map_after_with_signals.html'")

    gc.collect()

run_button.on_click(on_run_button_clicked)

# Display UI
display.display(VBox([n_cars_dropdown, run_button, tab]))

print("UI loaded. Select the number of cars and click 'Run Optimization' to see both Before and After results with costs in rupees.")

"""Quantum computing vs. Classical output."""

# Install required packages if not already installed (commented out for production)
# # !pip install osmnx folium ipywidgets numpy matplotlib IPython -q

import osmnx as ox
import networkx as nx
from collections import defaultdict
import folium
import numpy as np
import IPython.display as display
from itertools import combinations
import gc
import matplotlib.colors as mcolors
import ipywidgets as widgets
from ipywidgets import Output, VBox, Tab
import random

# Updated legend with traffic signal entry
legend_html = """
<div style="position: fixed; bottom: 50px; right: 50px; width: 180px; height: 260px;
            background-color: white; border:2px solid grey; z-index:9999; font-size:14px;">
 <b>Traffic Map Legend</b> <br>
 <i class="fa fa-exclamation-triangle fa-1x" style="color:red"></i> Traffic Jam <br>
 <span style="color:purple">Unique Colors</span> Car Routes (Before) <br>
 <i class="fa fa-car fa-1x" style="color:blue"></i> Car Start (Before) <br>
 <i class="fa fa-flag-checkered fa-1x" style="color:red"></i> Car End (Before) <br>
 <i class="fa fa-car fa-1x" style="color:green"></i> Car Start (After) <br>
 <i class="fa fa-flag-checkered fa-1x" style="color:darkgreen"></i> Car End (After) <br>
 <span style="color:green">Green Line</span> Smarter Route (After) <br>
 <i class="fa fa-traffic-light fa-1x" style="color:orange"></i> Traffic Signal <br>
</div>
"""

# Load graph for Times Square
def load_map():
    print("Loading map data for Times Square...")
    G = ox.graph_from_point((40.7558, -73.9864), dist=300, network_type='drive', simplify=False)
    ox.distance.add_edge_lengths(G)
    print(f"Graph loaded with {len(G.nodes)} nodes and {len(G.edges)} edges")
    return G

# Generate synthetic routes with forced congestion
def generate_synthetic_routes(G, n_cars=6):
    print(f"Generating {n_cars} synthetic routes...")
    nodes = list(G.nodes)
    if len(nodes) < 3:
        raise ValueError("Graph too small")
    original_routes = {}
    for car_id in range(n_cars):
        start, mid, end = random.sample(nodes, 3)
        try:
            path1 = nx.shortest_path(G, start, mid, weight='length')
            path2 = nx.shortest_path(G, mid, end, weight='length')
            route = path1[:-1] + path2
            edges = list(zip(route, route[1:]))
            original_routes[car_id] = [edges]
        except nx.NetworkXNoPath:
            print(f"Warning: No path for car {car_id}, using fallback single edge")
            edge = [(start, mid)] if G.has_edge(start, mid) else random.choice(list(G.edges()))
            original_routes[car_id] = [[edge]]
    segment_counts = defaultdict(int)
    for paths in original_routes.values():
        for u, v in paths[0]:
            segment_counts[(u, v)] += 1
    congested_segments = {seg: count for seg, count in segment_counts.items() if count >= 2}
    print(f"Generated routes for {len(original_routes)} cars, Congested segments: {len(congested_segments)}")
    return congested_segments, original_routes

# Identify critical intersections
def identify_critical_intersections(G, congested_segments, original_routes, min_distance=80):
    print("Identifying critical intersections based on congestion...")
    intersection_load = defaultdict(int)
    critical_intersections = {}
    signal_coords = []
    signal_directions = {}
    for (u, v), count in congested_segments.items():
        if G.has_edge(u, v) or G.has_edge(v, u):
            if u in G.nodes and v in G.nodes:
                intersection_load[u] += count
                intersection_load[v] += count
    for paths in original_routes.values():
        for u, v in paths[0]:
            if u in G.nodes and v in G.nodes and G.has_edge(u, v):
                if (u, v) in congested_segments or (v, u) in congested_segments:
                    intersection_load[u] += 1
                    intersection_load[v] += 1
    considered_nodes = set()
    for (u, v), _ in congested_segments.items():
        if G.has_edge(u, v) or G.has_edge(v, u):
            for node in [u, v]:
                if node in G.nodes and node not in considered_nodes:
                    considered_nodes.add(node)
                    lat1, lon1 = G.nodes[node]['y'], G.nodes[node]['x']
                    too_close_node = any(ox.distance.great_circle(lat1, lon1, lat, lon) < min_distance
                                       for lat, lon in signal_coords)
                    too_close_segment = any(G.has_edge(node, existing_node)
                                          for existing_node in critical_intersections)
                    if not (too_close_node or too_close_segment):
                        critical_intersections[node] = intersection_load[node]
                        signal_coords.append((lat1, lon1))
                        signal_directions[node] = determine_directions(G, node)
    for node in G.nodes:
        if node not in considered_nodes:
            lat1, lon1 = G.nodes[node]['y'], G.nodes[node]['x']
            close_to_congestion = any(ox.distance.great_circle(lat1, lon1, G.nodes[u]['y'], G.nodes[u]['x']) < 20
                                    or ox.distance.great_circle(lat1, lon1, G.nodes[v]['y'], G.nodes[v]['x']) < 20
                                    for u, v in congested_segments.keys() if G.has_edge(u, v) or G.has_edge(v, u))
            if close_to_congestion:
                too_close_node = any(ox.distance.great_circle(lat1, lon1, lat, lon) < min_distance
                                   for lat, lon in signal_coords)
                too_close_segment = any(G.has_edge(node, existing_node)
                                      for existing_node in critical_intersections)
                if not (too_close_node or too_close_segment):
                    critical_intersections[node] = intersection_load.get(node, 0)
                    signal_coords.append((lat1, lon1))
                    signal_directions[node] = determine_directions(G, node)
    print(f"Critical intersections: {len(critical_intersections)}")
    return critical_intersections, signal_directions

def determine_directions(G, node):
    directions = []
    if node not in G.nodes:
        return directions
    edges = [(u, v) for u, v in G.edges(node) if u == node or v == node]
    for u, v in edges:
        if u == node:
            lat1, lon1 = G.nodes[u]['y'], G.nodes[u]['x']
            lat2, lon2 = G.nodes[v]['y'], G.nodes[v]['x']
        else:
            lat1, lon1 = G.nodes[v]['y'], G.nodes[v]['x']
            lat2, lon2 = G.nodes[u]['y'], G.nodes[u]['x']
        delta_lon = lon2 - lon1
        delta_lat = lat2 - lat1
        angle = np.degrees(np.arctan2(delta_lon, delta_lat))
        if angle < 0:
            angle += 360
        if 315 <= angle or angle < 45:
            direction = "Northbound"
        elif 45 <= angle < 135:
            direction = "Eastbound"
        elif 135 <= angle < 225:
            direction = "Southbound"
        else:
            direction = "Westbound"
        directions.append(direction)
    return sorted(list(set(directions)))

# Find alternative routes
def find_alternative_routes(G, routes, congested_segments, max_alts=3):
    print("Finding alternative routes...")
    G_simple = nx.Graph(G) if G.is_multigraph() else G
    car_routes = {}
    for car_id, paths in routes.items():
        if not paths or not paths[0]:
            print(f"Warning: Car {car_id} had no initial path, using fallback")
            edge = random.choice(list(G.edges()))
            car_routes[car_id] = [[[edge]]]
            continue
        source, dest = paths[0][0][0], paths[0][-1][1]
        alts = []
        try:
            for path in nx.shortest_simple_paths(G_simple, source, dest, weight='length'):
                if len(alts) >= max_alts: break
                path_edges = list(zip(path, path[1:]))
                if path_edges and path_edges not in alts:
                    alts.append(path_edges)
            if not alts: raise nx.NetworkXNoPath
        except nx.NetworkXNoPath:
            print(f"Warning: No alternative path for car {car_id}, keeping original")
            alts = [paths[0]]
        car_routes[car_id] = alts[:max_alts]
    print(f"Generated alternative routes for {len(car_routes)} cars")
    return car_routes

# Classical redistribution of cars (Greedy approach)
def redistribute_cars_classically(routes, congested_segments):
    print("Redistributing cars using a classical greedy approach...")
    final_routes = {}
    segment_usage = defaultdict(int)

    # Sort cars randomly to avoid bias
    car_ids = list(routes.keys())
    random.shuffle(car_ids)

    for car_id in car_ids:
        alts = routes[car_id]
        best_alt = None
        min_congestion = float('inf')

        # Evaluate each alternative route
        for alt in alts:
            temp_usage = segment_usage.copy()
            for u, v in alt:
                temp_usage[(u, v)] += 1
            congestion_score = sum(temp_usage[(u, v)] for u, v in alt if (u, v) in congested_segments)
            if congestion_score < min_congestion:
                min_congestion = congestion_score
                best_alt = alt

        # Assign the best alternative and update segment usage
        if best_alt:
            final_routes[car_id] = [best_alt]
            for u, v in best_alt:
                segment_usage[(u, v)] += 1
        else:
            print(f"Warning: No valid alternative for car {car_id}, using first route")
            final_routes[car_id] = [alts[0]] if alts else [[]]

    print(f"Optimized routes for {len(final_routes)} cars")
    return final_routes

# Compute signal timings
def compute_signal_timings(G, critical_data, routes_before, routes_after=None):
    print("Computing signal timings with directions...")
    signal_timings = {}
    max_cycle = 120
    critical_intersections, signal_directions = critical_data
    for node in critical_intersections:
        routes_to_use = routes_after if routes_after else routes_before
        before_count = sum(1 for paths in routes_before.values() for u, v in paths[0] if u == node or v == node)
        after_count = sum(1 for paths in routes_to_use.values() for u, v in paths[0] if u == node or v == node)
        green = min(60, max(20, after_count * 2)) if after_count > 0 else max(20, before_count * 1.5)
        red = max_cycle - green - 5
        signal_timings[node] = {
            'green': green,
            'yellow': 5,
            'red': red,
            'coords': (G.nodes[node]['y'], G.nodes[node]['x']),
            'directions': signal_directions.get(node, [])
        }
        print(f"Traffic Signal @ Node {node}: Green={green}s, Red={red}s, Directions={', '.join(signal_directions.get(node, []))}")
    return signal_timings

# Visualize before optimization
def visualize_before(G, original_routes, congested_segments, critical_intersections, signal_directions):
    print("Visualizing before optimization...")
    m = folium.Map(location=(40.7558, -73.9864), zoom_start=15)
    color_list = list(mcolors.TABLEAU_COLORS.values()) + list(mcolors.CSS4_COLORS.values())[:24]
    unique_colors = color_list[:len(original_routes)]
    for (u, v), count in congested_segments.items():
        if u in G.nodes and v in G.nodes and G.has_edge(u, v):
            coords = [(G.nodes[u]['y'], G.nodes[u]['x']), (G.nodes[v]['y'], G.nodes[v]['x'])]
            folium.PolyLine(coords, color='red', weight=8, opacity=0.8, tooltip=f'Jam: {count} cars').add_to(m)
            folium.Marker(coords[0], icon=folium.Icon(color='red', icon='exclamation-triangle', prefix='fa')).add_to(m)
    visualized_cars = 0
    for car_id in range(len(original_routes)):
        path = original_routes.get(car_id, [[]])
        if path and path[0]:
            points = [(G.nodes[u]['y'], G.nodes[u]['x']) for u, v in path[0] if u in G.nodes and v in G.nodes and G.has_edge(u, v)]
            if not points:
                u, v = path[0][0] if path[0] else (list(G.nodes)[0], list(G.nodes)[1])
                points = [(G.nodes[u]['y'], G.nodes[u]['x'])]
                print(f"Warning: Car {car_id} has no valid edges in Before map, using start point")
            unique_points = list(dict.fromkeys(points))
            car_color = unique_colors[car_id % len(unique_colors)]
            print(f"Car {car_id} Before: Plotting {len(unique_points)} points at {unique_points}")
            folium.PolyLine(unique_points, color=car_color, weight=4, tooltip=f'Car {car_id}').add_to(m)
            folium.Marker(unique_points[0], icon=folium.Icon(color='blue', icon='car', prefix='fa'),
                         tooltip=f'Car {car_id} Start').add_to(m)
            end_point = unique_points[-1] if len(unique_points) > 1 else unique_points[0]
            folium.Marker(end_point, icon=folium.Icon(color='red', icon='flag-checkered', prefix='fa'),
                         tooltip=f'Car {car_id} End').add_to(m)
            visualized_cars += 1
        else:
            print(f"Warning: Car {car_id} has no route in Before map, plotting at default location")
            default_point = (G.nodes[list(G.nodes)[0]]['y'], G.nodes[list(G.nodes)[0]]['x'])
            folium.Marker(default_point, icon=folium.Icon(color='blue', icon='car', prefix='fa'),
                         tooltip=f'Car {car_id} Start (No Route)').add_to(m)
            folium.Marker(default_point, icon=folium.Icon(color='red', icon='flag-checkered', prefix='fa'),
                         tooltip=f'Car {car_id} End (No Route)').add_to(m)
            visualized_cars += 1
    signal_timings = compute_signal_timings(G, (critical_intersections, signal_directions), original_routes)
    for node, timings in signal_timings.items():
        directions_str = ", ".join(timings['directions']) if timings['directions'] else "All directions"
        folium.Marker(
            timings['coords'],
            icon=folium.Icon(color='orange', icon='traffic-light', prefix='fa', icon_size=(30, 30)),
            tooltip=f"Traffic Signal @ Node {node}: Green={timings['green']}s, Red={timings['red']}s, Directions={directions_str}"
        ).add_to(m)
        folium.Circle(timings['coords'], radius=20, color='orange', fill=True, fill_opacity=0.4).add_to(m)
    m.get_root().html.add_child(folium.Element(legend_html))
    print(f"Visualized {visualized_cars} cars in Before map")
    return m

# Visualize after optimization
def visualize_after_with_signals(G, optimized_routes, congested_segments, signal_timings):
    print("Visualizing after optimization with enhanced traffic signals...")
    m = folium.Map(location=(40.7558, -73.9864), zoom_start=15)
    for (u, v), count in congested_segments.items():
        if u in G.nodes and v in G.nodes:
            coords = [(G.nodes[u]['y'], G.nodes[u]['x']), (G.nodes[v]['y'], G.nodes[v]['x'])]
            folium.PolyLine(coords, color='red', weight=8, opacity=0.5, tooltip=f'Jam: {count} cars').add_to(m)
            folium.Marker(coords[0], icon=folium.Icon(color='red', icon='exclamation-triangle', prefix='fa')).add_to(m)
    visualized_cars = 0
    for car_id in range(len(optimized_routes)):
        paths = optimized_routes.get(car_id, [[]])
        if paths and paths[0]:
            points = []
            for u, v in paths[0]:
                if u in G.nodes and v in G.nodes:
                    points.append((G.nodes[u]['y'], G.nodes[u]['x']))
                else:
                    print(f"Warning: Invalid node pair ({u}, {v}) for car {car_id} in After map")
            if not points:
                u, v = paths[0][0] if paths[0] else (list(G.nodes)[0], list(G.nodes)[1])
                points = [(G.nodes[u]['y'], G.nodes[u]['x'])]
                print(f"Warning: Car {car_id} has no valid edges in After map, using start point")
            unique_points = list(dict.fromkeys(points))
            print(f"Car {car_id} After: Plotting {len(unique_points)} points at {unique_points}")
            folium.PolyLine(unique_points, color='green', weight=4, dash_array='5', tooltip=f'Car {car_id}').add_to(m)
            folium.Marker(unique_points[0], icon=folium.Icon(color='green', icon='car', prefix='fa'),
                         tooltip=f'Car {car_id} Start').add_to(m)
            end_point = unique_points[-1] if len(unique_points) > 1 else unique_points[0]
            folium.Marker(end_point, icon=folium.Icon(color='darkgreen', icon='flag-checkered', prefix='fa'),
                         tooltip=f'Car {car_id} End').add_to(m)
            visualized_cars += 1
        else:
            print(f"Warning: Car {car_id} has no route in After map, plotting at default location")
            default_point = (G.nodes[list(G.nodes)[0]]['y'], G.nodes[list(G.nodes)[0]]['x'])
            folium.Marker(default_point, icon=folium.Icon(color='green', icon='car', prefix='fa'),
                         tooltip=f'Car {car_id} Start (No Route)').add_to(m)
            folium.Marker(default_point, icon=folium.Icon(color='darkgreen', icon='flag-checkered', prefix='fa'),
                         tooltip=f'Car {car_id} End (No Route)').add_to(m)
            visualized_cars += 1
    for node, timings in signal_timings.items():
        directions_str = ", ".join(timings['directions']) if timings['directions'] else "All directions"
        folium.Marker(
            timings['coords'],
            icon=folium.Icon(color='orange', icon='traffic-light', prefix='fa', icon_size=(30, 30)),
            tooltip=f"Traffic Signal @ Node {node}: Green={timings['green']}s, Red={timings['red']}s, Directions={directions_str}"
        ).add_to(m)
        folium.Circle(timings['coords'], radius=20, color='orange', fill=True, fill_opacity=0.4).add_to(m)
    m.get_root().html.add_child(folium.Element(legend_html))
    print(f"Visualized {visualized_cars} cars in After map")
    return m

# UI and Main Logic
G = load_map()  # Load map once

# Widgets
n_cars_dropdown = widgets.Dropdown(options=[6, 12, 18, 24], value=6, description='Number of Cars:')
run_button = widgets.Button(description="Run Optimization")
output_before = Output()
output_after = Output()

# Tab layout for outputs
tab = Tab(children=[output_before, output_after])
tab.set_title(0, 'Before Optimization')
tab.set_title(1, 'After Optimization')

# Event handler for Run Optimization
def on_run_button_clicked(b):
    n_cars = n_cars_dropdown.value
    with output_before:
        output_before.clear_output()
        congested_segments, original_routes = generate_synthetic_routes(G, n_cars=n_cars)
        critical_intersections, signal_directions = identify_critical_intersections(G, congested_segments, original_routes)
        map_before = visualize_before(G, original_routes, congested_segments, critical_intersections, signal_directions)
        # Display the map as HTML to avoid unpacking or rendering issues
        display.display(display.HTML(map_before._repr_html_()))
        map_before.save("map_before.html")
        print("Before map saved as 'map_before.html'")

    with output_after:
        output_after.clear_output()
        optimized_routes = find_alternative_routes(G, original_routes, congested_segments)
        final_routes = redistribute_cars_classically(optimized_routes, congested_segments)
        signal_timings = compute_signal_timings(G, (critical_intersections, signal_directions), original_routes, final_routes)
        map_after = visualize_after_with_signals(G, final_routes, congested_segments, signal_timings)
        # Display the map as HTML to avoid unpacking or rendering issues
        display.display(display.HTML(map_after._repr_html_()))
        map_after.save("map_after_with_signals.html")
        print("After map saved as 'map_after_with_signals.html'")

    gc.collect()

run_button.on_click(on_run_button_clicked)

# Display UI
display.display(VBox([n_cars_dropdown, run_button, tab]))

print("UI loaded. Select the number of cars and click 'Run Optimization' to see both Before and After results.")

"""Computation time of Classical vs Quantum"""

